{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-08-04T10:21:10.417Z","updated":"2023-08-04T07:57:06.673Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2023-11-16T10:17:27.705Z","updated":"2023-08-04T07:57:06.674Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-08-05T11:10:39.068Z","updated":"2023-08-05T11:10:39.068Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2023-08-05T10:38:44.348Z","updated":"2023-08-04T07:57:06.674Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-10-19T03:43:33.503Z","updated":"2023-08-04T07:57:06.674Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-10-19T03:43:25.876Z","updated":"2023-08-04T07:57:06.674Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-10-19T03:44:45.069Z","updated":"2023-08-04T07:57:06.674Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"树形结构数据字典设计","slug":"树形结构数据字典设计","date":"2024-04-28T06:39:04.000Z","updated":"2024-04-28T09:27:52.474Z","comments":true,"path":"2024/04/28/树形结构数据字典设计/","link":"","permalink":"http://example.com/2024/04/28/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"背景最近接受一个小需求，对AI生成的对话记录提供点赞和反馈功能，反馈的内容由后端配置化 分析看到需求第一时间想到的是将反馈内容存入数据字典表，经分析，系统目前的字典表设计最多只支持两级，虽然说勉强可以实现，可是会用到一些硬编码。刚好这段时间也不是很忙，做人还是得有一些追求，于是就有了这张树形结构的数据字典表，通用于多级数据字典，便于后续需求扩展。重点就是在原有的基础上加一个PID字段。 编码1.Dao实现将入参字典类型匹配的字典项作为根节点，查找出根节点下的所有子孙节点，包含根节点本身，这里用到了自关联，因为我的mysql版本过低，不能用mysql自带的递归（WITH RECURSIVE 需要8.0及以上版本） 1234567891011121314151617181920212223242526SELECT d3.* FROM tb_sup_basic_dictitem d1 JOIN tb_sup_basic_dictitem d2 ON d1.id = d2.parent_id JOIN tb_sup_basic_dictitem d3 ON d2.id = d3.parent_id WHERE d1.dict_type = &#x27;mastone_report&#x27; UNION SELECT d2.* FROM tb_sup_basic_dictitem d1 JOIN tb_sup_basic_dictitem d2 ON d1.id = d2.parent_id WHERE d1.dict_type = &#x27;mastone_report&#x27; UNION SELECT d1.* FROM tb_sup_basic_dictitem d1 WHERE d1.dict_type = &#x27;mastone_report&#x27; 2.service实现将以上查询的结果集转成树形结构，也用到了递归 123456789101112131415161718192021222324252627282930313233343536373839404142434445public List&lt;BasicDictitem&gt; getByDictType(String dictType,boolean containSelf) &#123; // 1.查找出根dictType相关的所有字典项 List&lt;BasicDictitem&gt; itemList = basicDictitemMapper.findByDictType(dictType); // 2.将itemList转换成id,dictitem的map Map&lt;Long, BasicDictitem&gt; dictitemMap = itemList.stream() .collect(Collectors.toMap(BasicDictitem::getId, item -&gt; item)); // 3.将itemList转换成Map&lt;Long,List&lt;BasicDictitem&gt;&gt;，其中List&lt;BasicDictitem&gt;是按每个item对象中的parentId分组后的集合 Map&lt;Long, List&lt;BasicDictitem&gt;&gt; childrenMap = itemList.stream().filter(item -&gt; item.getParentId() != null) .collect(Collectors.groupingBy(BasicDictitem::getParentId)); // 4.找到根节点，并从根节点开始遍历，构建子孙节点 List&lt;BasicDictitem&gt; tree = new ArrayList&lt;&gt;(); for (BasicDictitem item : itemList) &#123; if (item.getParentId() == null) &#123; buildTreeRecursive(item, childrenMap); tree.add(item); &#125; &#125; // 6.如果需要包含自身，则添加到树中,默认不包含 if (containSelf)&#123; return tree; &#125; return tree.get(0).getChildren(); &#125; /** * 递归构建子孙节点 * @param parent * @param childrenMap */ private void buildTreeRecursive(BasicDictitem parent, Map&lt;Long, List&lt;BasicDictitem&gt;&gt; childrenMap) &#123; List&lt;BasicDictitem&gt; children = childrenMap.get(parent.getId()); if (children != null) &#123; for (BasicDictitem child : children) &#123; buildTreeRecursive(child, childrenMap); parent.getChildren().add(child); &#125; &#125; &#125; 3.controller实现123456789101112/** * 树形字典项通用接口，字典类型见tb_sup_basic_dictitem表 * @param dictType 字典类型 * @param containSelf 是否包含本身节点 * @return */@GetMapping(&quot;/getByDictType.json&quot;)public YlskResult getByDictType(@RequestParam String dictType, @RequestParam(value = &quot;containSelf&quot;,required=false,defaultValue = &quot;0&quot;)boolean containSelf)&#123; List&lt;BasicDictitem&gt; tree = basicDictitemService.getByDictType(dictType,containSelf); return YlskResult.newSuccess(tree);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&#123; &quot;success&quot;: true, &quot;code&quot;: 1, &quot;data&quot;: [ &#123; &quot;id&quot;: 3, &quot;parentId&quot;: 2, &quot;dictType&quot;: &quot;mastone_report_wrong&quot;, &quot;dictName&quot;: &quot;理解问题有误&quot;, &quot;children&quot;: [ &#123; &quot;id&quot;: 6, &quot;parentId&quot;: 3, &quot;dictType&quot;: &quot;mastone_report_wrong_1&quot;, &quot;dictName&quot;: &quot;没能理解指令&quot;, &quot;children&quot;: [ ] &#125;, &#123; &quot;id&quot;: 7, &quot;parentId&quot;: 3, &quot;dictType&quot;: &quot;mastone_report_wrong_2&quot;, &quot;dictName&quot;: &quot;未发现问题的错误&quot;, &quot;children&quot;: [ ] &#125;, &#123; &quot;id&quot;: 8, &quot;parentId&quot;: 3, &quot;dictType&quot;: &quot;mastone_report_wrong_3&quot;, &quot;dictName&quot;: &quot;无法理解上下文&quot;, &quot;children&quot;: [ ] &#125;, &#123; &quot;id&quot;: 9, &quot;parentId&quot;: 3, &quot;dictType&quot;: &quot;mastone_report_wrong_4&quot;, &quot;dictName&quot;: &quot;答非所问&quot;, &quot;children&quot;: [ ] &#125; ] &#125;, &#123; &quot;id&quot;: 4, &quot;parentId&quot;: 2, &quot;dictType&quot;: &quot;mastone_report_poor&quot;, &quot;dictName&quot;: &quot;回答不佳&quot;, &quot;children&quot;: [ &#123; &quot;id&quot;: 10, &quot;parentId&quot;: 4, &quot;dictType&quot;: &quot;mastone_report_poor_1&quot;, &quot;dictName&quot;: &quot;有事实性错误&quot;, &quot;children&quot;: [ ] &#125;, &#123; &quot;id&quot;: 11, &quot;parentId&quot;: 4, &quot;dictType&quot;: &quot;mastone_report_poor_2&quot;, &quot;dictName&quot;: &quot;回答对我没有帮助&quot;, &quot;children&quot;: [ ] &#125; ] &#125;, &#123; &quot;id&quot;: 5, &quot;parentId&quot;: 2, &quot;dictType&quot;: &quot;mastone_report_harm&quot;, &quot;dictName&quot;: &quot;有害信息&quot;, &quot;children&quot;: [ &#123; &quot;id&quot;: 12, &quot;parentId&quot;: 5, &quot;dictType&quot;: &quot;mastone_report_harm_1&quot;, &quot;dictName&quot;: &quot;敏感/有害信息&quot;, &quot;children&quot;: [ ] &#125;, &#123; &quot;id&quot;: 13, &quot;parentId&quot;: 5, &quot;dictType&quot;: &quot;mastone_report_harm_2&quot;, &quot;dictName&quot;: &quot;存在价值观问题&quot;, &quot;children&quot;: [ ] &#125; ] &#125; ]&#125;","categories":[],"tags":[{"name":"技术设计","slug":"技术设计","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1/"}]},{"title":"UML时序图","slug":"UML时序图","date":"2024-01-19T04:07:49.000Z","updated":"2024-01-19T04:08:33.613Z","comments":true,"path":"2024/01/19/UML时序图/","link":"","permalink":"http://example.com/2024/01/19/UML%E6%97%B6%E5%BA%8F%E5%9B%BE/","excerpt":"","text":"","categories":[],"tags":[{"name":"设计","slug":"设计","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"如何画好一张架构图/业务图/流程图，掌握这4个关键点(转载)","slug":"技术设计图掌握4个关键点","date":"2024-01-11T08:39:08.000Z","updated":"2024-01-11T10:36:05.718Z","comments":true,"path":"2024/01/11/技术设计图掌握4个关键点/","link":"","permalink":"http://example.com/2024/01/11/%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E5%9B%BE%E6%8E%8C%E6%8F%A14%E4%B8%AA%E5%85%B3%E9%94%AE%E7%82%B9/","excerpt":"","text":"原文链接简介： 作为一个开发，日常工作中免不了要画一些图，无论是技术架构图还是业务流程图。基于个人的一些经验，作者分享了他的作图方法，给大家一点思路提供参考，希望在未来的工作、生活中都能有所帮助。 来源｜阿里云开发者公众号 作者｜湘叶 前言今天的分享不是干货，是锦上添花的软技能。作为一个开发，日常工作中免不了要画一些图，无论是技术架构图还是业务流程图。基于个人的一些经验，分享一下我的作图方法，给大家一点思路提供参考，希望在未来的工作、生活中都能有所帮助。 一. 图例1. 代码实现图 2. 技术架构图 3. 业务流程图 4. 技术链路图 5. 交互时序图 Tips：以上图例均用语雀画板创作 二. 好图的定义 结构清晰：观点明确、主次分明、内容清楚 外表美观：有更多的浏览欲&#x2F;阅读欲 内容完整：一张图内容自闭环 三. 关键点如何让图结构更清晰？具有设计感，设计四大原则。如何让图外表更美观？具有美感，色轮的运用、黄金分割。如何让图内容更完整？以终为始的设计，用户为先的思想，信息补全&#x2F;添加标注。 1. 设计感：设计四大原则 亲密性：实现组织性（让有关系的元素挨在一起，有区别的元素分开） 对齐：使页面统一而且有条理（元素与元素之间存在一些对齐效果） 对比：增强页面的效果、有助于信息的组织（元素与元素之间存在一些对比效果） 重复：更统一，增强视觉效果（让类似的元素存在一样的效果&#x2F;样式） 将这些原则应用到图的线、块、面上。 Tips：世界著名设计师罗宾·威廉姆出版过一本畅销书，叫做《写给大家看的设计书》，里面提到了设计四大原则：亲密性、对齐、对比、重复，四大基本原则涵盖了品牌、电商、包装、UI等诸多领域，成为众多设计从业者必须掌握的设计原则。对于非设计的同学，也应该了解一下，提升自己的设计感。 2. 美感：色轮的运用 美术三原色：红黄蓝（在三色场景下，应用最多最广泛的颜色） 互补色：一种作为主色，另一种作为强调（在二色场景下，用互补色） 等距三色组：会让人愉悦的颜色组合（在三色场景下，使用等距三色组具有愉悦感） 采用同层级的颜色：具有和谐感的颜色组合（在多色场景下，采用同层级的颜色更具和谐） Tips：《写给大家看的设计书》里面提到了对颜色的运用，我们要从色轮上找到颜色的运用方法 3. 美感：黄金分割构图法 黄金分割：0.618（图的整体大小采用长1.618宽1的黄金比） 斐波那契数列：1，1，2，3，5，8，13，21，34，55，89……，当趋向于无穷大时，前一项与后一项的比值越来越逼近黄金分割0.618 Tips：黄金分割是指将整体一分为二，较大部分与整体部分的比值等于较小部分与较大部分的比值，其比值约为0.618。黄金比有严格的艺术感、和谐感，蕴藏丰富的美学价值，而且呈现于不少动物和植物的外观。现今普遍很多工业产品、电子产品、建筑物或艺术品均应用了黄金比，使其更美观。 4. 完整感：以终为始的设计 思考先行：以终为始的设计 列出所有要素：所有能帮助看图人理解的元素都要有，包括图例标注、箭头顺序、标题、注解 用户为先：把自己当作看图人，在没有上下文的情况下能获取到图中多少信息 在这里我们要借鉴以终为始的思维模式，在作图前我们要想清楚作这张图的目的是什么，是想要表达清楚什么，以及需要哪些元素，最终实现的效果就是通过一张图，就能完整地了解你的意图和目标。 Tips：史蒂芬·柯维的《高效能人士的七个习惯》中，“以终为始”，是第二个好习惯。“以终为始”是以所有事物都经过两次创造的原则为基础的。所有事物都有心智的，即第一次的创造(mental &#x2F;first creation)，和实际的，即第二次的创造(physical&#x2F;second creation)。我们做任何事都是先在心中构思，然后付诸实现。正因如此，认定使命才显得如此重要。 四. 结语 了解了这4个关键点，再回头看看第一部分的图例，是不是有更好的体感了。最后，4个关键点只是提升你的作图思维，具体XX架构图&#x2F;XX业务图&#x2F;XX流程图&#x2F;XX链路图&#x2F;XX时序图应该怎么画，每个人实操画出来的风格都不一样，就像有的人喜欢黑字白底、有的人喜欢白字黑底、有的人喜欢深色、有的人喜欢浅色等等，但只要遵循亲齐比复四大原则、色轮的运用、黄金分割构图法、以终为始的设计这4个关键点，画出来的图就不会太差，快来试试吧～","categories":[],"tags":[{"name":"设计","slug":"设计","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"系统设计的33个黄金法则","slug":"系统设计的33个黄金法则","date":"2024-01-11T08:39:08.000Z","updated":"2024-01-11T08:55:13.611Z","comments":true,"path":"2024/01/11/系统设计的33个黄金法则/","link":"","permalink":"http://example.com/2024/01/11/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%8433%E4%B8%AA%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99/","excerpt":"","text":"对于数据密集型系统 — 考虑使用缓存。 对于写入量大的系统 — 使用消息队列进行异步处理 对于低延迟要求 — 考虑使用缓存和 CDN。 需要𝐀原子性、𝐂一致性、𝐈隔离性、𝐃耐用性兼容数据库 — 选择 RDBMS&#x2F;SQL 数据库。 对于非结构化数据——可以选择NoSQL数据库。 拥有复杂的数据（视频、图像、文件）——选择 Blob&#x2F;对象存储。 复杂的计算——使用消息队列和缓存。 海量数据搜索——考虑搜索索引、尝试搜索引擎。 扩展 SQL 数据库 — 实施数据库分片。 高可用性、性能和吞吐量 — 使用负载均衡器。 全球数据交付——考虑使用 CDN。 图形数据（具有节点、边和关系的数据）——利用图形数据库。 扩展各种组件——实现水平扩展。 高性能数据库查询——使用数据库索引。 批量作业处理——考虑批处理和消息队列。 服务器负载管理和防止 DOS 攻击 - 使用速率限制器。 微服务架构——使用 API 网关。 针对单点故障——实施冗余。 为了容错性和持久性——实施数据复制。 对于用户到用户的快速通信 — 使用 Websockets。 分布式系统中的故障检测——实现心跳。 数据完整性——使用校验和算法。 高效的服务器扩展——一致性哈希。 去中心化数据传输——考虑 Gossip 协议。 基于位置的功能 — 使用四叉树、Geohash 等。 避免特定的技术名称 — 使用通用术语。 高可用性和一致性的权衡——最终一致性。 对于IP解析和域名查询——DNS。 处理网络请求中的大数据——实施分页。 缓存删除策略 — 首选 LRU（最近最少使用）缓存。 处理流量高峰：实现自动扩展以动态管理资源 审计跟踪 — 考虑使用数据湖 处理高并发连接 — 使用连接池并考虑使用 Protobuf 来最小化数据","categories":[],"tags":[{"name":"设计","slug":"设计","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"Homebrew介绍","slug":"Homebrew介绍","date":"2023-11-24T02:51:53.000Z","updated":"2023-12-01T12:16:05.051Z","comments":true,"path":"2023/11/24/Homebrew介绍/","link":"","permalink":"http://example.com/2023/11/24/Homebrew%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"Homebrew 是 macOS 上的一款包管理工具，用于简化软件的安装和管理。以下是 Homebrew 的基本使用教程： 安装 Homebrew：打开终端（Terminal）并执行以下命令安装 Homebrew： 12bashCopy code/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 这个命令会下载并安装 Homebrew。 使用 Homebrew 安装软件： 安装软件： 使用 Homebrew 安装软件非常简单，只需执行以下命令： 12bashCopy codebrew install &lt;软件名称&gt; 例如，要安装 Git，可以运行： 12bashCopy codebrew install git 更新 Homebrew： 保持 Homebrew 及其软件包是最新的，定期执行以下命令： 12bashCopy codebrew update 卸载软件： 卸载已安装的软件包可以使用 brew uninstall 命令： 12bashCopy codebrew uninstall &lt;软件名称&gt; 查看已安装的软件： 查看已安装的软件列表： 12bashCopy codebrew list 搜索软件包： 想要查找特定软件包是否可用，可以使用 brew search： 12bashCopy codebrew search &lt;关键词&gt; 例如，搜索 Python： 12bashCopy codebrew search python 查看软件信息： 查看软件包的详细信息： 12bashCopy codebrew info &lt;软件名称&gt; 例如，查看 Git 的信息： 12bashCopy codebrew info git 清理不需要的文件： 清理 Homebrew 下载的临时文件和旧版本： 12bashCopy codebrew cleanup 这些是 Homebrew 的基本用法。使用这些命令，你可以方便地安装、更新和管理软件包。在 Homebrew 中，Formulae 和 Casks 分别用于管理两类软件包：命令行工具和图形界面应用。以下是它们的区别： Formulae（公式）： 类型： Formulae 是用于安装命令行工具（通常是不带图形界面的程序）的规范。 安装路径： 安装的命令行工具通常会被放置在 /usr/local/bin 目录下，使其可以通过命令行直接调用。 例子： 安装 Git 或 Python 的命令如下： 123bashCopy codebrew install gitbrew install python Casks（瓶子）： 类型： Casks 用于安装图形界面应用，这些应用通常有用户界面，例如浏览器、编辑器、办公软件等。 安装路径： Casks 安装的应用通常位于 /Applications 目录下，就像你手动安装的应用一样。 例子： 安装 Google Chrome 或 Visual Studio Code 的命令如下： 123bashCopy codebrew install --cask google-chromebrew install --cask visual-studio-code 通过这种方式，Homebrew 提供了一种统一的管理方式，使用户可以方便地通过命令行安装和管理不同类型的软件包。你可以使用 brew install 安装 Formulae，而对于 Casks，你需要使用 brew install --cask。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"hexo个人博客搭建","slug":"hexo个人博客搭建","date":"2023-11-21T03:06:46.000Z","updated":"2023-11-27T02:47:03.035Z","comments":true,"path":"2023/11/21/hexo个人博客搭建/","link":"","permalink":"http://example.com/2023/11/21/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"为什么要搭建个人博客 俗话说：“好记性不如烂笔头” 记录在本地磁盘痛点：检索困难、容易丢失、分类归档体验差等 记录在第三方平台（简书、CSDN、掘金）痛点：UI界面丑、有违规风险、账号密码记不住等 搭建个人博客工具调研 WordPress是一款强大的内容管理系统，适合非技术用户，有大量主题和插件。但可能需要更多资源，对定制性有一定限制。 Jekyll和Hugo是静态网站生成器，生成速度快，安全性高。Jekyll基于Ruby，Hugo基于Go，两者都适合技术用户，但Jekyll在大型项目中可能较慢，而Hugo则更快。 Hexo是基于Node.js的静态博客生成器，简单易用，生成速度快，适合追求速度和轻量级的用户。然而，相比Jekyll和Hugo，Hexo的生态相对较小。 Hexo环境准备 Node.js和npm：在Node.js官网下载最新版本的Node.js安装包，并按照安装向导进行安装。Node.js会自动包含npm。 1234~ node -vv14.20.1~ npm -v6.14.17 Git：在Git官网下载最新版本的Git安装包，按照安装向导进行安装。Git是Hexo用于版本控制的工具。 12~ git --versiongit version 2.32.1 (Apple Git-133) 搭建步骤 安装Hexo： 打开命令行或终端，运行以下命令安装Hexo： 1npm install -g hexo-cli 创建博客： 在你希望创建博客的文件夹内，运行以下命令初始化Hexo博客： 1hexo init myblog 进入博客目录： 1cd myblog 安装依赖： 1npm install 启动本地服务器： 1hexo server 在浏览器中访问 http://localhost:4000，你将能够看到正在搭建的博客。 选择主题： Hexo支持许多主题，你可以在Hexo官方主题列表中选择一个你喜欢的主题，并按照主题文档进行安装和配置。 这里选择：https://github.com/leedom92/hexo-theme-leedom 1npm i hexo-theme-leedom 在根目录下的_config.yml文件中修改主题的配置 12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/##theme: puretheme: leedom 重新构建，焕然一新 12hexo cleanhexo s 编写文章： 在 source/_posts 目录下创建Markdown文件，写下你的文章内容。 生成静态文件： 12bashCopy codehexo generate 这会在 public 目录下生成最终的静态文件。 部署博客： 如果你想将博客部署到GitHub等平台，按照相应平台的配置和Hexo文档中的部署章节进行操作。 安装 Hexo 的 GitHub 部署插件： 1npm install hexo-deployer-git --save 在 _config.yml 中配置 GitHub Pages 部署信息： 1234deploy: type: git repo: https://github.com/username/username.github.io.git branch: master 运行以下命令将 Hexo 站点部署到 GitHub Pages： 123hexo clean hexo generatehexo deploy hexo常用命令： 1234567891011121314# 1.初始化博客hexo init &lt;folder&gt;# 2.启动本地服务器hexo server# 3.创建新文章hexo new &lt;title&gt;# 4.生成静态文件hexo generate# 5.部署博客hexo deploy# 6.清理缓存hexo clean# 7.查看帮助hexo --help","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"我与ChatGPT的日常对话","slug":"我与ChatGpt的日常对话","date":"2023-11-15T16:00:00.000Z","updated":"2023-11-16T08:07:50.494Z","comments":true,"path":"2023/11/16/我与ChatGpt的日常对话/","link":"","permalink":"http://example.com/2023/11/16/%E6%88%91%E4%B8%8EChatGpt%E7%9A%84%E6%97%A5%E5%B8%B8%E5%AF%B9%E8%AF%9D/","excerpt":"","text":"","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"简洁代码片段","slug":"简洁代码片段","date":"2023-11-14T16:00:00.000Z","updated":"2023-11-16T08:07:59.440Z","comments":true,"path":"2023/11/15/简洁代码片段/","link":"","permalink":"http://example.com/2023/11/15/%E7%AE%80%E6%B4%81%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/","excerpt":"","text":"代码标准：简洁、易读、易扩展 1.填充客户列表「是否已经添加计划」标签1234567891011private void loadAddPlanLabel(List&lt;VisitCustInfo&gt; resultList, Long supUserId, String planTime) &#123; List&lt;String&gt; custIds = resultList.stream().map(VisitCustInfo::getCustId).collect(Collectors.toList()); Map&lt;String,VisitCustInfo&gt; map = resultList.stream() .collect(Collectors.toMap(VisitCustInfo::getCustId,item -&gt; item)); List&lt;String&gt; addPlanCustIds = custVisitMapper.findVistPlan(custIds,supUserId,planTime); if (!CollectionUtils.isEmpty(addPlanCustIds)) &#123; addPlanCustIds.stream().forEach(custId -&gt; &#123; map.get(custId).setAddDayPlan(true); &#125;); &#125; &#125; 2.填充客户列表「当月已拜访次数」标签1234567891011private void loadVisitCountLabel(List&lt;VisitCustInfo&gt; resultList, Long supUserId) &#123; List&lt;String&gt; custIds = resultList.stream().map(VisitCustInfo::getCustId).collect(Collectors.toList()); Map&lt;String,VisitCustInfo&gt; map = resultList.stream() .collect(Collectors.toMap(VisitCustInfo::getCustId,item -&gt; item)); List&lt;VisitCustInfo&gt; visitedCustList = custVisitMapper.findVistCount(custIds,supUserId); if (!CollectionUtils.isEmpty(visitedCustList))&#123; visitedCustList.stream().forEach(visitCustInfo -&gt; &#123; map.get(visitCustInfo.getCustId()).setVisitCountCurMonth(visitCustInfo.getVisitCountCurMonth()); &#125;); &#125; &#125;","categories":[],"tags":[{"name":"coding","slug":"coding","permalink":"http://example.com/tags/coding/"}]},{"title":"Bug等级划分","slug":"Bug等级划分","date":"2023-10-30T16:00:00.000Z","updated":"2023-10-31T03:38:30.439Z","comments":true,"path":"2023/10/31/Bug等级划分/","link":"","permalink":"http://example.com/2023/10/31/Bug%E7%AD%89%E7%BA%A7%E5%88%92%E5%88%86/","excerpt":"","text":"软件Bug的来源Bug，原意为虫子，现在通常指软件缺陷、故障、问题等。 第一代计算机是由许多庞大且昂贵的继电器组成，并利用大量的电力来使继电器工作。可能正是由于计算机运行产生的光和热，引得一只小虫子Bug钻进了一支继电器内，导致整个计算机无法工作。 研究人员费了半天时间，总算发现原因所在，把这只小虫子从继电器中取出后，计算机又恢复正常。后来，Bug这个名词就沿用下来，表示电脑系统或程序中隐藏的错误、缺陷，漏洞或问题。 软件Bug的等级软件bug一般分为四种或五种等级，不同的软件领域，划分的可能略有差异，但大同小异。 一级（致命）Bug 通常表现为：主流程无法跑通，系统无法运行，崩溃或严重资源不足，应用模块无法启动或异常退出，主要功能模块无法使用。 比如： 1.内存泄漏； 2.严重的数值计算错误； 3.系统容易崩溃； 4.功能设计与需求严重不符； 5.系统无法登陆； 6.循坏报错，无法正常退出。 二级（严重）Bug通常表现为：影响系统功能或操作，主要功能存在严重缺陷，但不会影响到系统稳定性。 比如：1.功能未实现；2.功能存在报错；3.数值轻微的计算错误。 三级（一般）Bug通常表现为：界面、性能缺陷。 比如：1.边界条件下错误；2.容错性不好；3.大数据下容易无响应；4.大数据操作时，没有提供进度条。 四级（提示）Bug通常表现为：易用性及建议性问题比如：1.界面颜色搭配不好；2.文字排列不整齐；3.出现错别字，但是不影响功能；4.界面格式不规范。","categories":[],"tags":[{"name":"项目管理","slug":"项目管理","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]},{"title":"中国历史朝代纪年表","slug":"中国历史朝代纪年表","date":"2023-10-30T16:00:00.000Z","updated":"2023-12-07T03:15:27.495Z","comments":true,"path":"2023/10/31/中国历史朝代纪年表/","link":"","permalink":"http://example.com/2023/10/31/%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E6%9C%9D%E4%BB%A3%E7%BA%AA%E5%B9%B4%E8%A1%A8/","excerpt":"","text":"中国朝代顺口溜三皇五帝夏商周，春秋战国乱悠悠。秦汉三国东西晋，南朝北朝是对头。隋唐五代又十国，宋元明清帝王休。 中国历代皇帝顺序表秦朝(公元前221 - 207年)秦始皇嬴政、秦二世胡亥、秦三世子婴。 西汉(公元前202 – 公元8年)汉高祖刘邦、汉惠帝刘盈、汉文帝刘恒、汉景帝刘启、汉武帝刘彻、汉昭帝刘弗陵、汉宣帝刘淘、汉元帝刘奭、汉成帝刘蔫、汉哀帝刘欣、汉平帝刘行、孺子婴(王莽摄政)。 东汉(25 - 220年)光武帝刘秀、汉明帝刘庄、汉章帝刘炟、汉和帝刘肇、汉殇帝刘隆、汉安帝刘祜、汉顺帝刘保、汉冲帝刘炳、汉质帝刘赞、汉桓帝刘志、汉灵帝刘宏、汉献帝刘协。 三国(220 - 265年)魏国: 魏文帝曹丕、魏明帝曹叡、魏齐王曹芳、高贵乡公曹髦、魏元帝曹奂 蜀国: 昭烈帝刘备、后主刘禅 吴国: 武烈帝孙坚、长沙桓王孙策、吴大帝孙权、吴会稽王孙亮、吴景帝孙休、吴乌程侯孙皓晋 西晋(265 - 317年)晋武帝司马炎、晋惠帝司马衷、晋怀帝司马炽、晋愍帝司马邺。 东晋(317 - 420年)晋元帝司马睿、晋明帝司马绍、晋成帝司马衍、晋康帝司马岳、晋穆帝司马聘、晋哀帝司马丕、海西公司马奕、简文帝司马昱、孝武帝司马窑、晋安帝司马德宗、晋恭帝司马德文。 北朝(386年 - 581年)北魏: 道武帝拓跋珪、明元帝拓跋嗣、太武帝拓跋焘、南安王拓跋余、文成帝拓跋浚、献文帝拓跋弘、孝文帝元宏、宣武帝元恪、孝明帝元诩、幼主元钊、孝庄帝元子攸、长广王元晔、节闵帝元恭、安定王元朗、孝武帝元惰 东魏: 孝静帝元善见 西魏: 文帝元宝炬、废帝元钦、恭帝拓跋廓 北齐: 神武帝高欢、文襄帝高澄、文宣帝高洋、废帝高殷、孝昭帝高演、武成帝高湛、后主高纬、安德王高延宗、幼主高恒、范阳王高绍义 北周: 文帝宇文泰、孝闵帝宇文觉、明帝宇文毓、武帝宇文邕、宣帝宇文赞、静帝宇文衍 南朝(420 - 589年)宋: 宋武帝刘裕、宋少帝刘义符、宋文帝刘义隆、宋孝武帝刘骏、宋前废帝刘子业、宋明帝刘或、宋后废帝刘昱、宋顺帝刘准 齐(萧齐): 齐高帝萧道成、齐武帝萧赜、齐明帝萧鸾、东昏侯萧宝、齐和帝萧宝融 梁(萧梁): 梁武帝萧衍、简文帝萧纲、梁文帝萧绎、梁晋帝萧方智 陈(南陈): 陈武帝陈霸先、陈文帝陈蓓、陈废帝陈伯宗、陈宣宗陈顼、陈后主陈叔宝 隋朝(581 - 618年)隋文帝杨坚、隋炀帝杨广、隋恭帝杨侑 唐朝(618 - 907年)唐高祖李渊、唐太宗李世民、唐高宗李治、武后武则天（武瞾)、唐中宗李显、唐睿宗李旦、唐玄宗李隆基、唐肃宗李享、唐代宗李豫、唐德宗李适、唐顺宗李涌、唐宪宗李纯、唐穆宗李恒、唐敬宗李湛、唐文宗李昂、唐武宗李炎、唐宣宗李忱、唐懿宗李准、唐僖宗李儇、唐昭宗李晔、唐哀帝李祝。 北宋(960 - 1127年)宋太祖赵匡胤、宋太宗赵匡义、宋真宗赵恒、宋仁宗赵祯、宋英宗赵曙、宋神宗赵顼、宋哲宗赵煦、宋徽宗赵佶、宋钦宗赵桓。 南宋(1127 - 1276年)宋高宗赵构、宋孝宗赵音、宋光宗赵惇、宋宁宗赵扩、宋理宗赵昀、宋度宗赵樭、宋恭帝赵显。 元朝(1260 - 1368年)元世祖忽必烈、元成宗、元武宗、元仁宗、元英宗、元泰定帝、元天顺帝、元文宗、元明宗、元宁宗、元顺帝。 明朝(1368 - 1644年)明太祖朱元璋、明惠帝朱允炆、明成祖朱棣、明仁宗朱高炽、明宣宗朱瞻基、明英宗朱祁镇、明代宗朱祁钰、明英宗朱祁镇、明宪宗朱见深、明孝宗朱祐搅、明武宗朱厚娥、明世宗朱厚燎、明穆宗朱载屋、明神宗朱翊钧、明光宗朱常洛、明熹宗朱由校、明思宗朱由检。 清朝(1616 - 1912年)清太祖努尔哈赤、清太宗皇太极、清世祖顺治福临、清圣祖康熙玄烨、清世宗雍正胤慎、清高宗乾隆弘历、清仁宗嘉庆顒琰、清宣宗道光旻宁、清文宗咸丰奕、清穆宗同治载淳、清德宗光绪载恬、清宣统帝溥仪。","categories":[],"tags":[{"name":"历史","slug":"历史","permalink":"http://example.com/tags/%E5%8E%86%E5%8F%B2/"}]},{"title":"浅谈技术负债","slug":"浅谈技术负债","date":"2023-10-29T16:00:00.000Z","updated":"2023-10-30T08:28:41.412Z","comments":true,"path":"2023/10/30/浅谈技术负债/","link":"","permalink":"http://example.com/2023/10/30/%E6%B5%85%E8%B0%88%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA/","excerpt":"","text":"何为技术债务技术债务：是指在软件开发过程中，为了快速交付产品或功能而采取的技术上的妥协或权衡。它类似于财务债务，是对未来付出代价的承诺。技术债务可以包括未完成的功能、低质量的代码、技术陈旧或过时、缺乏文档和测试覆盖等。这些债务会增加软件系统的复杂性、降低可维护性，并增加未来开发和维护的成本。与财务债务类似，技术债务也需要及时偿还，以确保软件系统的质量和可持续性。技术团队通常会努力减少技术债务，并在合适的时机进行技术债务的还清和重构。 技术债务如何偿还技术债务的偿还是一个重要的过程，它有助于改善软件系统的质量和可维护性。以下是一些常见的技术债务偿还策略： 重构代码：通过重构低质量的代码，改善其可读性、可维护性和性能。这包括使用最佳实践和设计模式来优化代码结构和逻辑。 添加测试覆盖：为没有足够测试覆盖的代码编写单元测试、集成测试和端到端测试。这样可以更好地保证代码的正确性和稳定性。 更新技术栈：评估和更新过时的技术和工具，以提高系统的性能、安全性和可维护性。这可能涉及到升级框架、库和依赖项，以及采用新的开发实践和工具。 改进文档和注释：完善代码的文档和注释，使其更易于理解和维护。这有助于新的开发人员快速上手，并减少未来开发的困惑和错误。 优化性能：识别并解决系统中的性能问题，包括减少响应时间、提高并发处理能力和优化资源利用率。 追踪技术债务：建立技术债务的追踪和管理机制，以确保它们得到适时的关注和处理。这可以通过使用专门的工具或集成到项目管理工具中来实现。 需要注意的是，技术债务的偿还需要权衡时间、资源和优先级。团队应该根据项目的需求和优先级，制定合理的计划和策略来偿还技术债务，以最大程度地提高软件系统的质量和可持续性。 我在项目中如何管理技术债 利用JIRA来记录技术债： JIRA中新建任务类型：技术债务 （业务代码）业务小组通过在迭代过程中发现并记录到Jira backlog中 （基础组件）架构小组至少每个月主动去cod review一次以上，发现并记录到Jira backlog中 分析并评估backlog中每个技术债的优先级和工时 产品迭代过程中，评估下个版本业务需求范围时，适当地、合理地安排工期短、优先级高的技术债纳入版本范围，并全员宣讲，每日站会跟进 对于中低优先级的技术债，以月或季为纬度，单独建立冲刺，临时成立研发+测试小组，利用空档时间来处理，每周周会跟进","categories":[],"tags":[{"name":"技术债","slug":"技术债","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF%E5%80%BA/"}]},{"title":"JVM知识点","slug":"JVM知识点","date":"2023-10-26T16:00:00.000Z","updated":"2023-10-30T07:05:29.467Z","comments":true,"path":"2023/10/27/JVM知识点/","link":"","permalink":"http://example.com/2023/10/27/JVM%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1.JVM的区域划分 程序计数器（Program Counter）：线程私有，程序计数器是一块较小的内存区域，它保存着当前线程执行的字节码指令的地址。在线程切换时，程序计数器用于恢复执行的位置。 Java 虚拟机栈（Java Virtual Machine Stack）：线程私有，每个线程在运行时都会创建一个对应的虚拟机栈，用于存储方法的局部变量、操作数栈、动态链接、方法出口等信息。虚拟机栈的大小可以通过 -Xss 参数进行调整。 本地方法栈（Native Method Stack）：线程私有，本地方法栈与虚拟机栈类似，但是它为本地方法（Native Method）服务。本地方法是使用其他语言（如 C&#x2F;C++）编写的方法，通过 JNI（Java Native Interface）与 Java 程序进行交互。 Java 堆（Java Heap）：线程共享，Java 堆是 Java 程序运行时创建的对象的存储区域。它是垃圾回收的主要区域，包括新生代和老年代 新生代（Young Generation）：新生代是 Java 堆的一部分，用于存储新创建的对象。新生代通常被划分为 Eden 空间和两个 Survivor 空间（From 和 To）。大部分对象在新生代被创建和销毁。 老年代（Old Generation）：老年代用于存储生命周期较长的对象。经过多次垃圾回收后仍然存活的对象会被转移到老年代。老年代的空间通常较大。 方法区（Method Area）：线程共享，方法区用于存储类的结构信息（如类名、方法名、字段名）、静态变量、常量池等。在 JDK 1.8 中，方法区被移除，取而代之的是元空间（Metaspace）。 元空间（Metaspace）：线程共享，元空间取代了 JDK 1.8 之前的永久代（Permanent Generation）。元空间用于存储类的元数据信息，包括类的结构、方法、字段、常量池等。元空间的大小默认是不受限制的，但受到操作系统的限制。 以上是 java 8 的内存区域划分。需要注意的是，不同版本的 JDK 可能会有细微的差异，特别是在垃圾回收和内存管理方面 2.堆的区域划分在 Java 的堆（Heap）内存中，可以进一步划分为以下几个区域： 新生代（Young Generation）：新生代是堆内存中的一部分，用于存储新创建的对象。新生代可以进一步划分为 Eden 空间和两个 Survivor 空间（通常称为 From 和 To 空间） Eden(伊甸园) 空间：Eden 空间是新对象的初始分配区域。当 Eden 空间满时，触发一次 Minor GC（Young GC） Survivor(幸存者) 空间：Survivor 空间是用于存放在 Minor GC 过程中幸存下来的对象。在每次 Minor GC 后，仍然存活的对象会被复制到 Survivor 空间中的一个空闲区域。而上一次 GC 时的 Survivor 空间则会被清空 老年代（Old Generation）：老年代是存放经过多次 Minor GC 后仍然存活的对象的区域。老年代的对象一般具有较长的生命周期。当老年代空间不足时，会触发一次 Major GC（Full GC） 元数据区（Metaspace）：元数据区是用于存储类的元数据信息，包括类的结构、方法、字段、常量池等。在较新的 JDK 版本中，元数据区取代了传统的永久代（Permanent Generation）。元数据区的大小默认是不受限制的，但受到操作系统的限制 大对象区域（Large Object Space）：大对象区域是专门用于存储较大的对象，避免在新生代和老年代中频繁进行内存拷贝。一般情况下，大对象直接分配在大对象区域 需要注意的是，堆内存的划分可能会因为不同的垃圾回收器（Garbage Collector）策略而有所不同。不同的垃圾回收器在堆内存划分和对象分配上有不同的优化方式。 3.java的局部变量、成员变量、静态变量、类、对象等内存是如何分配的在 Java 中，局部变量、成员变量、静态变量、类和对象的内存分配如下： 局部变量（Local Variables）：局部变量是在方法、构造器或代码块内部定义的变量。它们在方法被调用时创建，并在方法执行结束后销毁。局部变量的内存分配在栈（Stack）上进行，存储在栈帧（Stack Frame）中。 成员变量（Instance Variables）：成员变量是在类中定义的变量，属于类的实例。每个类的实例都有自己的成员变量副本。成员变量的内存分配在堆（Heap）上进行，当创建对象时，会为每个实例分配一块堆内存来存储成员变量。 静态变量（Static Variables）：静态变量是在类中定义的使用 static 修饰的变量，属于类本身而不是类的实例。静态变量的内存分配在方法区（Method Area）中，它们在程序启动时初始化，并在整个程序运行期间存在。 类（Class）：类的定义在方法区中，包括类的结构、字段、方法和字节码等信息。类的信息在程序加载时被加载到方法区中，并在整个程序运行期间存在。 对象（Objects）：对象是类的实例化，每个对象都有自己的一块堆内存空间来存储实例变量。对象的内存分配在堆上进行，当使用关键字 new 创建对象时，会在堆中分配一块连续的内存空间来存储对象的实例变量。 需要注意的是，局部变量和方法参数在方法调用结束后会被销毁，而成员变量和静态变量的生命周期与对象和类的生命周期相关。 4.JVM的垃圾回收机制是怎样的JVM（Java虚拟机）的垃圾回收机制是自动管理和释放内存的一种机制，用于回收不再使用的对象，以提供更多的可用内存空间。 垃圾回收机制的基本原理是通过标记和清除（Mark and Sweep）的过程来确定哪些对象可以被回收。以下是垃圾回收机制的主要步骤： 标记（Marking）：从根对象（如堆栈中的局部变量和静态变量）开始，递归地遍历所有可访问的对象，并将它们标记为“活动”对象。未被标记的对象即为“垃圾”对象。 清除（Sweeping）：在标记完成后，垃圾回收器会扫描整个堆内存，将未被标记的对象释放，并回收它们占用的内存空间。被标记的对象将保留下来，用于后续的内存分配。 压缩（Compacting）：在清除阶段之后，为了提高内存的连续性和空间利用率，一些垃圾回收器还会执行内存压缩操作。压缩过程会将存活的对象紧凑地移动到堆的一端，以便在另一端释放更多的连续内存空间。 垃圾回收机制的具体实现可以有多种算法和策略，如标记-清除算法、复制算法、标记-整理算法等。不同的垃圾回收器（如Serial、Parallel、CMS、G1等）使用不同的算法和策略，以适应不同的应用场景和性能需求。 通过垃圾回收机制，Java程序可以更方便地管理内存，避免显式地进行内存释放操作，减少内存泄漏和内存溢出的风险。 5. oracle jdk 1.8.0_321 触发垃圾回收的时机在 Oracle JDK 1.8.0_321（Java 8 Update 321）中，垃圾回收的时机是由 JVM（Java虚拟机）自动管理的，我们无法直接触发垃圾回收。 JVM 使用了一种称为 “自适应垃圾回收” 的策略来判断何时执行垃圾回收操作。它基于以下几个因素来决定是否触发垃圾回收： 堆内存的使用情况：当堆内存中的对象达到一定的阈值时，JVM 可能会触发垃圾回收来释放不再使用的对象。 内存分配速率：JVM 会监控对象的分配速率。如果分配速率过高，可能导致堆内存快速填满，JVM 可能会触发垃圾回收来释放不再使用的对象。 系统资源：JVM 还会考虑系统的资源情况，如 CPU 使用率和可用内存等。如果系统资源紧张，JVM 可能会触发垃圾回收来释放内存资源。 请注意，以上是一些触发垃圾回收的常见因素，具体的策略可能会因 JVM 的版本和配置而有所不同。此外，我们也可以通过一些参数来调整垃圾回收的行为，例如 -XX:MaxGCPauseMillis 参数可以指定最大垃圾回收停顿时间。 总之，在 Oracle JDK 1.8.0_321 中，垃圾回收的时机是由 JVM 自动管理的，基于堆内存使用情况、内存分配速率和系统资源等因素来判断何时执行垃圾回收操作。 6.什么场景下会触发新生代的垃圾回收新生代的垃圾回收是由 JVM（Java虚拟机）自动触发的，通常在以下情况下会触发年轻代的垃圾回收： Minor GC（部分垃圾回收）：当新对象被分配到年轻代时，如果年轻代空间不足，JVM 会触发 Minor GC。Minor GC 主要清理年轻代中不再使用的对象，以释放空间供新对象使用。 对象年龄达到阈值：年轻代中的对象会根据其存活时间进行年龄计数。当对象经过多次 Minor GC 后仍然存活，并且达到一定的年龄阈值时，JVM 会将这些对象晋升到老年代。晋升到老年代的过程也会触发年轻代的垃圾回收。 空间分配担保失败：在进行 Minor GC 时，如果存活对象太多，导致年轻代无法容纳所有存活对象，JVM 可能会进行一次 Full GC（完全垃圾回收）。在 Full GC 之前，为了确保空间分配的安全性，JVM 会先触发一次年轻代的垃圾回收。 请注意，年轻代的垃圾回收是 JVM 内部自动管理的过程，我们无法直接触发或控制。JVM 根据对象的生命周期和内存分配情况来判断何时进行垃圾回收操作。 7.什么场景下会触发老年代的垃圾回收老年代的垃圾回收是由 JVM（Java虚拟机）自动触发的，通常在以下情况下会触发老年代的垃圾回收： Major GC（完全垃圾回收）：当老年代空间不足时，JVM 会触发 Major GC。Major GC 主要清理老年代中不再使用的对象，以释放空间供新对象使用。 晋升担保失败：在进行 Minor GC 时，如果存活对象太多，导致老年代无法容纳所有存活对象，JVM 可能会进行一次 Full GC（完全垃圾回收）。在 Full GC 之前，JVM 会先触发一次老年代的垃圾回收，以尽量减少 Full GC 的频率。 显式调用 System.gc()：尽管不建议显式调用 System.gc() 方法，但在某些情况下，我们可能会手动触发垃圾回收。当调用 System.gc() 方法时，JVM 可能会同时触发年轻代和老年代的垃圾回收。 需要注意的是，老年代的垃圾回收相对较少发生，因为老年代中的对象通常具有较长的生命周期。JVM 会根据对象的存活时间和内存分配情况来判断何时进行垃圾回收操作。 请注意，我们通常不建议频繁地手动触发垃圾回收，因为 JVM 在内部已经有自动的垃圾回收机制来管理内存。频繁的垃圾回收可能会导致性能下降，应该根据具体情况进行调优和配置。 8.对象的存活时间对象的存活时间是指对象从被创建到被垃圾回收之间的时间段。在 Java 中，对象的存活时间可以分为以下几种情况： 瞬时对象（Transient Objects）：瞬时对象是指那些在方法中创建并在方法执行结束后立即被销毁的对象。它们的存活时间非常短暂，仅在方法的生命周期内存在。 局部对象（Local Objects）：局部对象是在方法中定义的对象，它们的作用域仅限于方法内部。当方法执行结束后，局部对象会被销毁，它们的存活时间与方法的执行时间相对应。 成员对象（Member Objects）：成员对象是在类中定义的对象，它们的生命周期与类的实例相关。当类的实例不再被引用时，成员对象会随着实例一起被垃圾回收。 静态对象（Static Objects）：静态对象是在类中定义的 static 修饰的对象，它们的生命周期与类的生命周期相同。静态对象在程序运行期间一直存在，直到程序结束或类被卸载时才会被垃圾回收。 长生命周期对象（Long-lived Objects）：长生命周期对象是指存活时间较长的对象，它们通常分配在老年代。这些对象可能是全局缓存、持久化对象等，它们的存活时间可能会跨越多个方法调用或甚至整个应用程序的生命周期。 需要注意的是，对象的存活时间由 JVM 内部的垃圾回收算法和内存分配策略来决定。JVM 会根据对象的引用关系、内存分配情况以及垃圾回收的算法来判断对象的存活时间，并相应地进行垃圾回收。 9.oracle jdk 1.8.0_321 的参数设置在 Oracle JDK 1.8.0_321 中，有许多参数可以用来调整 JVM（Java虚拟机）的行为。以下是一些常见的参数及其解释，包括一些示例： -Xmx&lt;size&gt;：设置最大堆内存大小。&lt;size&gt; 是以字节为单位的整数值，或者带有 g 或 G 后缀的以 GB 为单位的整数值。例如，-Xmx2g 表示将最大堆内存设置为 2 GB。 -Xms&lt;size&gt;：设置初始堆内存大小。&lt;size&gt; 的格式和单位与 -Xmx 参数相同。例如，-Xms512m 表示将初始堆内存设置为 512 MB。 -Xmn&lt;size&gt;：设置年轻代的大小。&lt;size&gt; 的格式和单位与 -Xmx 参数相同。例如，-Xmn256m 表示将年轻代的大小设置为 256 MB。 -XX:MaxPermSize=&lt;size&gt;：设置最大永久代（PermGen）大小。&lt;size&gt; 的格式和单位与 -Xmx 参数相同。例如，-XX:MaxPermSize=128m 表示将最大永久代大小设置为 128 MB。 -XX:ParallelGCThreads=&lt;num&gt;：设置并行垃圾回收的线程数。&lt;num&gt; 是一个整数值，表示线程的数量。例如，-XX:ParallelGCThreads=4 表示使用 4 个线程进行并行垃圾回收。 -XX:+UseConcMarkSweepGC：启用并发标记清除（CMS）垃圾回收器。例如，-XX:+UseConcMarkSweepGC 表示使用 CMS 垃圾回收器。 -XX:+PrintGCDetails：在控制台上打印详细的垃圾回收信息。例如，-XX:+PrintGCDetails 表示打印详细的垃圾回收信息。 这些只是一小部分常见的参数，还有许多其他参数可以用来调整 JVM 的行为。您可以参考 Oracle JDK 文档中的详细参数列表来了解更多选项和说明。 请注意，不同的 JDK 版本可能会有不同的参数和行为，因此建议在具体应用中根据需求和性能进行适当的调整和配置。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2023-10-18T16:00:00.000Z","updated":"2023-11-06T06:44:15.778Z","comments":true,"path":"2023/10/19/Git常用命令/","link":"","permalink":"http://example.com/2023/10/19/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查看当前项目的所有远程分支1234567git branch -r# 如果只想查看远程分支的名称，可以使用 --list 或 -l 选项git branch -r --list# 查看当前分支的远程地址git remote show origin# 删除远程分支git push origin --delete feature/branch-1 查看当前项目的所有本地分支1234567git branch # 如果只想查看远程分支的名称，可以使用 --list 或 -l 选项git branch --list# 如果想查看本地分支的详细信息，可以使用 -v 选项git branch -v# 删除本地分支git branch -d feature/branch-1 查看某个分支的最近一次提交12# 使用 -1 选项可以限制日志输出为只显示一次提交git log -1 prod-v3.9.1 查看某个作者的最近一次提交12# &lt;author-name&gt; 是你要查找的作者的名称git log --author=&quot;John Doe&quot; -n 1 查看当前分支某个文件的最近一次提交12# HEAD表示最新的提交git show head src/main/java/com/ylsk/b2b3/service/sys/UserAgentService.java 查看某一次提交的所有文件 12# &lt;commit-hash&gt; 是你要查看的提交的哈希值或引用git show --name-only 4505f7817a4f56b4e8581ea8985609b7ef47748b 查看某一次提交的某个文件的详细内容1git show 4505f7817a4f56b4e8581ea8985609b7ef47748b wyt/custMap/CustMapSurveyInfoToESRepo.yml 合并分支12# 注意如果有冲突发生，你需要解决冲突并手动提交修改。冲突文件会在合并日志中显示git merge &lt;other_branch&gt; 暂存当前分支改动123456# 1.暂存当前分支的改动代码git stash# 2.切换到目标分支git checkout feature/branch-1# 3.弹出之前分支暂存的改动代码git stash pop","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"markdown常用语法","slug":"markdown常用语法","date":"2023-09-27T10:23:20.697Z","updated":"2023-11-21T03:06:05.489Z","comments":true,"path":"2023/09/27/markdown常用语法/","link":"","permalink":"http://example.com/2023/09/27/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445# 这是一级标题## 这是二级标题###### 这是六级标题&gt; 这是一个有两段的块引用。这是第一段&gt; &gt; 这是第二段。Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; 这是另一个只有一个段落的块引用。有三个空行分割两个块引用。### 无序列表* 红色* 绿色* 蓝色### 有序列表1. 红色2. 绿色3. 蓝色### 任务列表- [ ] 这是一个任务列表项- [ ] 需要在前面使用列表的语法- [ ] 未完成- [x] 完成### 代码块例如：~~~ruby 代码 ~~~### 表格| 第一列 | 第二列 | 第三列 || ------ | ------ | ------ || 第一行 | 1 | 张三 || 第二行 | 2 | 李四 || 第三行 | 3 | 王五 |### 水平线***### 链接this is [ an example](http://example.com/ &quot;Title&quot;) inline link.[ this link ](http://example.net/) has no title attribute.### URL网址&lt;www.google.com&gt;### 高亮必须先到设置中启用它。==高亮==### HTML您可以使用HTML来设置纯 Markdown 不支持的内容，例如， &lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt; 用于添加红色文本。### 表情符号输入表情符号的语法是 :smile:","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-08-04T07:11:45.955Z","updated":"2024-01-11T08:36:43.754Z","comments":true,"path":"2023/08/04/hello-world/","link":"","permalink":"http://example.com/2023/08/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"技术设计","slug":"技术设计","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1/"},{"name":"设计","slug":"设计","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"coding","slug":"coding","permalink":"http://example.com/tags/coding/"},{"name":"项目管理","slug":"项目管理","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"历史","slug":"历史","permalink":"http://example.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"技术债","slug":"技术债","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF%E5%80%BA/"},{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]}