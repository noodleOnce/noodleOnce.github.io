{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"书单","date":"2023-11-16T10:17:27.705Z","updated":"2023-08-04T07:57:06.674Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-10-19T03:44:45.069Z","updated":"2023-08-04T07:57:06.674Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-10-19T03:43:25.876Z","updated":"2023-08-04T07:57:06.674Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-08-05T10:38:44.348Z","updated":"2023-08-04T07:57:06.674Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-10-19T03:43:33.503Z","updated":"2023-08-04T07:57:06.674Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2023-08-04T10:21:10.417Z","updated":"2023-08-04T07:57:06.673Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-08-05T11:10:39.068Z","updated":"2023-08-05T11:10:39.068Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"自己对管理的理解","slug":"自己对管理的理解","date":"2024-06-13T02:53:58.000Z","updated":"2024-06-13T02:56:47.831Z","comments":true,"path":"2024/06/13/自己对管理的理解/","link":"","permalink":"http://example.com/2024/06/13/%E8%87%AA%E5%B7%B1%E5%AF%B9%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"管理者日常： 观察市场动态，竞品分析，领悟上级领导工作指示，寻找公司或部门未来发展方向 定长远目标、定长远计划 陪同下属分解目标，分解计划，制定短期目标和计划 制定规章制定和流程，提升团队效率 传达工作讲三句话：将结果(目标)、将因果(逻辑)、将后果(价值) 对待下属：放权、承担、鼓励、帮助 原则：管理不是自己实现目标，而是引导团队完成目标","categories":[],"tags":[{"name":"管理","slug":"管理","permalink":"http://example.com/tags/%E7%AE%A1%E7%90%86/"}]},{"title":"管理到底管什么？","slug":"管理到底管什么？","date":"2024-05-29T01:21:35.000Z","updated":"2024-05-29T02:33:11.131Z","comments":true,"path":"2024/05/29/管理到底管什么？/","link":"","permalink":"http://example.com/2024/05/29/%E7%AE%A1%E7%90%86%E5%88%B0%E5%BA%95%E7%AE%A1%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"原文:https://mp.weixin.qq.com/s/_EM7gfmEzhPH0-dYngQAZg 管理 这个词大家一点都不陌生，但是，到底什么是管理？管什么？理什么？却是众说纷纭，很多人认为，管理就是“管人”和“理事”，还有人说是“管事”和“理人”，这么理解固然无错，但个人认为，这很抽象和片面。我记得我第一次读到彼得德鲁克先生关于管理的理解的时候，那叫一种震撼，就像是被什么东西击中了一样，他说，管理的本质就是“激发善意”。“科学管理之父”泰罗认为：“管理就是确切地知道你要别人干什么，并使他用最好的方法去干”。那么，对于一个组织来说，到底是管什么？理什么呢？ 01管理模型图管理模型长什么样子的呢？管理模型是指企业为实现其经营目标的组织资源、生产经营活动的基本框架和方式。通俗来讲就是企业管理套路，有了这个套路，避免从头开始进行摸索，管理模型的作用就是抽象和概括管理的思想和框架，在这个思想和框架下建立一系列管理体系。 02 管理中的“四管 管理有四大基本职能，分别是计划、组织、领导和控制。它们是管理过程中不可或缺的要素。无论是企业组织、团队、机构还是其他组织形式，都需要应用这四大职能来实现组织目标、优化资源利用和协调各项工作。 1.管住“人”的行为管理最核心的就是对人的管理。管人要管什么？——思想和行为。人的管理最终要落实在人的思想和行为上，思想决定行为，思路决定出路。人的思想和行为直接影响着工作质量和工作效率。行为受到意识、技能和标准的制约。所以，要通过岗位素质要求、标准化作业、技能培训、检查、指导、考核、激励和沟通等方式规范和约束人的行为。 2.管住“物”的状态物的状态分三个方面，一是存在状态、二是防护状态、三是账目状态。国内当前很多企业不断推起精益成本理念的学习，其中一个重要原因就是想有效实施“物的状态”管理，从根本上消除各类浪费。我们应当应从建章立制、信息化建设、可视化监控、内部评审等方面加强物的管理。 3.管住“事”的结果。企业管理过程中，最为常用的一就是PDCA闭环管理法，任何事情要遵循“计划、实施、检查、处置”的完整闭环。管住“事的结果”，常规来说，就是抓好执行力，做到“五有五必有”（有工作必有目标、有目标必有方案、有方案必有方计划、有计划必有检查、有检查必有结果）。在管理活动中，本着四不放过和PDCA原则的同时，善于运用先进的管理工具（如防呆改善、QC、A3、8D报告、审核评价）等方法做好“事”的管理。 4.管住“钱”的效率钱的效率主要体现在两个方面，一是钱要用在该用的地方。需要用钱的地方得要评估评审，花掉多少不是问题，花得值不值才是关键，杜绝大手大脚造成不必要的浪费。二是堵住钱的漏洞。企业得有严格的审批流程及权限设置、从企业的预算管理、采购系统、物流系统等方面必须得有制约机制、内部审计、会计监督，加强“钱”的使用和监督管理。 03 管理过程中的“八理 一个组织或团队，面对“人、事、物、资、时、效”等管理要素，要理的东西特别多，各个环节错综复杂，那到底要理什么，作为管理者抓得住命脉，否则你就是累死也理不清楚，干不出成效。 1.把战略理“优”。企业的战略定位和战略规划是企业方向和命脉，是企业持续、健康发展的关键。所以、我们应该从企业的战略使命和愿景出发，运用科学和系统的分析方法，如SWOT分析，对公司自身的竞争优势、劣势、机会和威胁进行分析，从而将公司的战略与公司的内部资源、外部环境有机结合起来。并形成公司的战略规划，对战略进行实施和控制。 2.把目标理“准”。 企业要战略愿景及规划，必须建立起内部科学、系统的目标管理体系。按照中长期和短期进行目标制定，从上而下层层分解，从下而上逐级支撑，把目标分解到最小单元，落实到每一个具体的作业层面。目标管理的核心是“精”——抓住关键的重点项。而不是“多”，目标太多，并不是好事，土话说“眉毛胡子一把抓”，反而把自己搞得手忙脚乱。这里给大家推荐目标管理的SMART原则。 3.把风险理“低”。企业在经营过程中，会遇到来自内部和外部的各种风险，这些风险包括政策的变化、市场的波动、产品、财务及运营带来的风险。这些风险如果不及时识别和控制，会给企业带来不可估量的，甚至是灾难性损失。所以，应该按照相关标准要求，建立公司的风险防范机制。 4.把制度理“通”。一个健康的企业要法制，不要人治，制度是最好的领导。制度管理远比人的管理要规范、有序和效率。但是，很多企业和管理者不善于建章立制，把工作要求和标准停留在口头上，时间久了，就会带来政令上朝令夕改、执行上大打折扣。其次，即使有制度，也是泛泛而谈，全是纲领性的文字，根本不能落地。所以，建章立制上应着力解决好管理制度的“合理、适用”问题。把制度建完整，把节点理通，这样才能“有法可依，有法必依”。 5.把职责理“清”。任何工作都应遵循“职责明确、目标清晰”的八字原则，任何管理工作都应该把责任明确到个人头上，不要交叉负责，否则，大家管大家都不管。明确职责的同时要把目标量化，要有时限和可量化的数字标准，同时，职责要和管理制度、手册、程序有机结合。否则，带来的将是推诿扯皮。通常情况下，推诿扯皮的理由是：不知道该谁干、不知道怎么干、不知道何时干、不知道干到什么程度。 6.把流程理“顺”。流程一定要跟“权”和“责”结合起来，并和时间目标和绩效考核挂钩，这样才能提高流程效率。很多企业机构设置臃肿、流程与业务不匹配办事拖拉、环节过多审批繁琐、流程不透明，无法监督而效率低下。所以，应通过分级流程图明确责任，必要时可以结合办公自动化系统提高流程速度。 7.把标准理“精”。作业标准“模板化”是指导员工规范、高效作业的依据，是是员工技能快速均衡较好的方法。生产和管理过程中产生的各种浪费、工作效率低下等问题，与企业缺乏可操作性的作业标准有很大的关系。应按照标准化、精细化、目视化管理的要求，建立简洁、明了、可操作的作业标准。 8.把信息理“畅”。企业管理过程有三个流：人流、物流和信息流。其中，信息流对数据分析、问题发现、正确决策、过程控制、绩效考核、持续改进起着至关重要的作用。我们应该明确信息需求、信息传递方式及传递渠道，让各级决策者能及时了解有关生产和经营信息。如果有条件，可以通过Mes、ERP等信息系统进行信息流的管理。","categories":[],"tags":[{"name":"项目管理","slug":"项目管理","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]},{"title":"Java动态代理","slug":"Java动态代理","date":"2024-05-28T02:11:33.000Z","updated":"2024-05-28T03:40:53.662Z","comments":true,"path":"2024/05/28/Java动态代理/","link":"","permalink":"http://example.com/2024/05/28/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"1.什么是动态代理？Java中的动态代理是一种在运行时动态创建代理类和对象的机制。动态代理允许在不修改原有类代码的情况下，通过代理类来扩展或重写原有类的方法，对原有类的功能进行增强。 2.为什么会有动态代理？开放封闭原则：类应该对扩展开放，对修改关闭。 3.动态代理使用步骤： 被代理的类：需要实现一个或多个接口 代理类：需要实现InvocationHandler接口，该类负责定义在代理对象上调用方法时的实际行为。 创建代理实例：使用Proxy.newProxyInstance()方法创建代理对象，该方法需要传入三个参数：类加载器、接口数组(被代理的接口类)和InvocationHandler实例（代理类实例）。 使用代理对象：通过代理对象调用方法，实际调用的是InvocationHandler的invoke()方法，可以在这个方法中定义代理逻辑。 4.使用案例：场景刚刚接手一个陈旧多年的电商项目，需要在下单完成后给用户发送一条消息，提升用户体验。 原订单接口 原订单接口实现类 订单接口代理类 使用代理类下单","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"像素 / 分辨率 / 物理像素和逻辑像素","slug":"像素-分辨率-物理像素和逻辑像素","date":"2024-05-27T10:17:35.000Z","updated":"2024-05-29T02:05:28.592Z","comments":true,"path":"2024/05/27/像素-分辨率-物理像素和逻辑像素/","link":"","permalink":"http://example.com/2024/05/27/%E5%83%8F%E7%B4%A0-%E5%88%86%E8%BE%A8%E7%8E%87-%E7%89%A9%E7%90%86%E5%83%8F%E7%B4%A0%E5%92%8C%E9%80%BB%E8%BE%91%E5%83%8F%E7%B4%A0/","excerpt":"","text":"原文:https://juejin.cn/post/6844904094344151054 写在前面无论是在日常用电脑手机等电子设备，还是做设计、前端开发等工作都需要时刻和像素 &#x2F; 分辨率打交道，比如在你电脑上运行的占满整个屏幕的项目演示到别人电脑上只显示出一半，别人告诉你说是因为你的电脑屏幕分辨率太大了，你一脸蒙蔽。又比如听别人告诉你说分辨率大小就是你的屏幕大小，你看者你手机上写的分辨率和你电脑上的分辨率一样大小，你看看你小小的手机，再看看你大大的电脑，内心OS：这屏幕能一样大？？？ 你去搜专业的维基百科关于分辨率到底是个啥，你又看到一堆专业术语，好吧，你放弃了。。。 那么分辨率到底是个啥，对我们日常生活、工作有什么用处，这里整理总结简单叙述如下。 1 关于像素 上面的像素图，我们都很熟悉，可能小时候也做过像素拼豆豆这样的手工。其实这就是在电脑上构成图片显示出来的原理，电脑上显示的图像就是由一个个有色彩的小方格拼接起来组成的，那么为什么我们一眼看不出来呢？那是因为电脑上划分的一个个的小方格太小了，很密集，拼接起来就欺骗我们的肉眼看起来就是一条条线画出来的图了。 比如我们正常看到的图片是这样的： 多么可爱的一幅画，看起来就像是我们在纸上画出来的线条画出来的样子，但实际上你放大 n 倍去看，看到的是这样的： PS：图片是在 PS 中被无限放大的，电脑的图片查看不允许放大这么多倍。 看到了吧，也是和我们常见的像素图是一样的，也是一格格地拼凑起来的，这么小小的一个图片，拼凑成其的小格子有好几万个，所以在我们肉眼看来就成了线条。 上述的一个个的小格子被定义为一个单位，叫做 像素 ，2像素就是指占据了两个小格子的大小，当然，我们描述一个图片占的小格子数总不能一个个地数小格子吧，图片是矩形，因此常常描述一个图片尺寸时就说多少乘多少像素，像素就是小格子，比如上面的这个图片的尺寸就是 300 * 300 像素，也就是说该图片的长、宽都有300个小格子，该图片一共占 300 * 300 = 90000 个小格子。 因此小格子就是像素，1像素 就是一个小格子的大小，你若问那 1像素 到底有多大，多少厘米或毫米？ 停，都说了小格子是个矩形，要论大小也得是多少平方厘米或平方毫米，但是小格子的大小就是 1像素，像素是个像厘米或毫米一样的定义好的单位，专门用于电子屏幕上描述图形尺寸的单位，但是像素不像厘米、毫米等长度单位一样有固定的大小，像素是没有固定大小的，奇怪吧，但事实就是这样，只要知道 1像素 就是一个小格子就可以了。 2 从像素到分辨率知道了 像素 ，再来讨论下屏幕尺寸 关于各种设备屏幕的尺寸是以 英寸 为单位的，英寸是一个长度单位，是有固定大小的，可以去百度换算下单位成厘米看看有多大。比如我的电脑尺寸是 15.6 英寸，注意各种电子设备的屏幕尺寸指的是屏幕斜对角线的大小，不然你想，屏幕不也是个矩形吗？怎么能用一个长度单位描述呢？应该是 长度 * 宽度 描述吧。由于显示屏幕不是胡乱设计比例的，是有固定比例的，如 16 : 9 、4 : 3 等等，因此屏幕给出斜对角线的大小，具体屏幕矩形的长宽就可以根据屏幕的设计比例计算出来 现在显示屏准备好了，如何将图片显示出来呢？那就将屏幕划分成一个个的小格子，然后在对应位置给小格子上色，全部上完色，图片自然就出来了。 那么屏幕如何划分小格子呢？就像我们画表格一样，横着、竖着加线条，就划分成了一排排的小格子。那么将 长和宽 分别划分成多少个小格子呢？这就涉及到了分辨率，分辨率就是用于描述屏幕长度和宽度分别划分成多少个小格子。比如常见的分辨率是 1920 * 1080 ，实际含义就是屏幕的宽有 1920 个小格子，长有 1080 个小格子，整个屏幕的小格子数就是 1920 * 1080 = 2073600 个。足够欺骗我们的肉眼了。 所以分辨率就是指显示屏的长宽均划分成多少个小格子，小格子的单位是像素，因此又称屏幕分辨率为 1920 * 1080 像素。分辨率就以像素为单位来衡量了。 分辨率影响了什么？分辨率影响了我们的视觉，若屏幕分辨率很低，如 15.6 英寸的显示屏分辨率为 100 * 100 像素，那么一个小格子得占多大，肉眼就看得到小格子的轮廓了，那体验多不好，就像在看像素图一样难受。此时若将上述的图片显示在 100 * 100 分辨率的 15.6 英寸的屏幕上，能显示的全吗？上述图片可是占 300 * 300 像素的大小的，只能显示 1 &#x2F; 3的图片。 这也就是说为什么同样的图片在不同分辨率的显示上大小不一样了，因为这个图片占的小格子数是一定的，但是每个设备的像素(小格子)大小不一样，显示的图片大小就不一样。因此 1像素 的具体大小在不同的设备上是不一样的，同样的屏幕尺寸，分辨率越高的，划分的小格子数越多，同一个图片显示出来的大小就越小，但是会越清晰。反之则很大但很模糊。 3 图片放大缩小一般情况下点开图片查看时是将图片的一个小格子对应到一个显示屏幕的小格子。 但图片在被放大或者缩小后，图片的像素小格子便不再是一一对应于显示屏幕的分辨率划分出的物理小格子了，图片放大 3 倍，则一个图片小格子就占据 3 个物理小格子大小显示，因此图片就看起来放大了，甚至超出屏幕大小。 图片缩小到 0.5，则一个图片小格子就占据半个物理小格子，看起来就缩小了。 4 物理像素 &#x2F; 逻辑像素从上述的图片放大缩小可以看出，图片尺寸所标注的 300 * 300 像素大小并不一定时刻等同于设备上的像素大小，放大3倍后就是 图片的 1像素格子 &#x3D;&#x3D;&#x3D; 设备的 3像素格子，缩小后又变小了。 因此将上述设备不能改变的、在设备一生产出来后就确定的像素称作 物理像素 ，也叫 设备像素(device pixels)，简称 dp 。 与之对应的用于表示图片尺寸、可时刻改变的像素称作 逻辑像素，也叫 设备独立像素(device independent pixels)，简称 dip 。 二者的比值被定义为一个新的概念叫做 设备像素比(devicePixelRatio)，简称 dpr ，运算公式为 DPR = 设备像素 / 设备独立像素。 在一般的电脑上，设备像素是等于逻辑像素的，也就是 dpr = 1.0 ，但是在高分辨率的电脑上，二者不一定相等，浏览器提供了一个接口可以查看二者的关系。可用 window.devicePixelRatio 属性查看，如在我的电脑上获取的结果如下： 问题: 那么问题来了，为什么要有物理像素和逻辑像素之分呢？直接用物理像素表示一个图片的大小不行吗？从原则上是可以，但是如果将图片的尺寸用物理像素表示，那么会带来很大的问题，例如，有两台电脑，屏幕尺寸完全一样，一个分辨率是 1920 * 1080 ，一个是 960 * 540 ，那么二者同时放一个 300 * 300 物理像素大小的图片，那么你会看到什么？ 你会看到同一个图片在两台电脑上的大小完全不一样，在高分辨率电脑上图片比低分辨率电脑上的小得多，因为我图片就占 300 * 300 个物理格子，高分辨率的电脑物理格子小，占满 300 * 300 个也还是小，低分辨率的电脑分的物理格子大，占满 300 * 300 个格子就要大。 那就会出现这样一个情况，我们俩电脑尺寸完全一样，看到的同一个图片大小差别那么大，这体验完全不好啊，况且现在无论手机端、还是PC端，厂家生产显示器时都往死里提高分辨率，你会发现你的手机分辨率甚至比电脑还大，那手机看到的图片该得多小啊。 因此，为了使网络资源浏览起来更舒服，也就是让两个屏幕尺寸一样大的设备，呈现的同一个图片看起来差不多是一样大的，因此就发明了 逻辑像素，规定所有在电子设备上呈现的图片等资源的尺寸统一用 逻辑像素 表示，发明了 逻辑像素 后如何实现相同屏幕尺寸但分辨率不同的设备上显示的图片一样大呢？ 实现的方法就是降低那些分辨率贼高但是屏幕尺寸很小的设备的 dpr ，即 设备像素比，从而得到不同的 逻辑像素 ，例如 300 * 300 逻辑像素大小的图片，有屏幕尺寸相同的两个设备 A &#x2F; B，A 的分辨率为 1920 * 1080， B 的分辨率是 960 * 540 ，那么就设置 A 的 dpr = 0.5 ，从而得到在 A 设备中 1dip = 2dp，A 设备中设置 dpr = 1.0 ，这样同一个图片在 B 设备中一个小格子占一个物理格子，在 A 设备中，因为 A 的物理小格子小，那就占 2 个格子，这样呈现的两个图片大小就看起来是一样大的了。 每个设备在生产时都会规定好逻辑像素比的，上述只是举例，不同设备的具体 dpr可以去查，因此可以得出结论：逻辑像素的大小是随设备不同而不同的，与逻辑像素比和物理像素均有关。虽然 逻辑像素 的产生基本解决了物理像素产生的问题，但是也并不能绝对保证两个图片在每个相同设备上都一样大，比如两个手机的尺寸不一样，一个小的，一个大的，但是二者的 dpr 都是 2.0 ,在分辨率一样的情况下那屏幕尺寸小的肯定显示的图片小些。但基本不会差太多。 5 改变逻辑像素比对于一个设备来说，其物理像素是固定大小的，其逻辑像素比有一个初始值，但是可以改变的，例如网页的缩放、图片的放大缩小都可以改变 dpr ，呈现不同的网页、图片大小。如下是我将网页放大后得到的 dpr ： 但网页的逻辑像素尺寸还是不变的，只是通过改变 dpr 来改变一个逻辑像素占几个物理像素来改变视图大小的。逻辑尺寸和物理尺寸都不变，仅仅通过改变 dpr 逻辑像素比来改变视觉大小，是不是很神奇？","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"言论摘抄","slug":"言论摘抄","date":"2024-05-24T07:23:57.000Z","updated":"2024-05-24T07:25:49.014Z","comments":true,"path":"2024/05/24/言论摘抄/","link":"","permalink":"http://example.com/2024/05/24/%E8%A8%80%E8%AE%BA%E6%91%98%E6%8A%84/","excerpt":"","text":"1.20多岁时，我跟一个长辈说：“我很担心，别人会怎么看待我做的那个决定。”长辈说：“放心吧，你没有观众的。” 现在想起来，我认为这是我得到过的最好建议。 – 阿曼达·福蒂尼（Amanda Fortini），美国作家 2.大量的面试和考试，基本上是在测试你能在多大程度上替代编译器。比如，Java 认证考试倾向于考察语法和编译问题，而不是实际编程的能力或系统设计的能力。 – 《我是程序员而不是编译器》 3.我的职业建议是，行动要急不可耐，对于结果要抱有耐心。 – 《给年轻自己的职业建议》","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"文摘摘抄","slug":"文摘摘抄","date":"2024-05-24T07:18:47.000Z","updated":"2024-05-24T07:28:01.727Z","comments":true,"path":"2024/05/24/文摘摘抄/","link":"","permalink":"http://example.com/2024/05/24/%E6%96%87%E6%91%98%E6%91%98%E6%8A%84/","excerpt":"","text":"1、CEO 和三个信封[50]一家陷入困境的公司，聘请了一位新的 CEO。 即将卸任的前 CEO 私下会见了他，并向他赠送了三个有编号的信封。“如果你遇到了重大麻烦，请打开这些信封，每次只能打开一个。”前 CEO 说。 三个月过去了，公司的销售额和利润仍然在大幅下降，新任 CEO 受到了很大的压力。 他开始惊慌，但随后他想起了那些信封。他从抽屉里拿出第一个信封，上面写着：“责怪你的前任。” 新任 CEO 就召开新闻发布会并解释说，前任给他留下了烂摊子，清理它的时间比预期要长，但一切都在正确的轨道上。媒体和华尔街对他的解释感到满意，做出了积极回应。 又一个季度过去了，公司仍在苦苦挣扎。吸取了之前的经验，他就打开了第二个信封，上面写着：“重组。” 因此，他解雇了员工，整合了部门，尽可能地削减成本，华尔街和媒体都对他的努力表示赞赏。 三个月过去了，公司的销售额和利润仍然裹足不前。他在财报电话会议前，走进办公室，关上门，打开第三个信封，上面写着：“准备三个信封。”","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"系统架构图","slug":"系统架构图","date":"2024-05-06T09:02:40.000Z","updated":"2024-05-28T03:47:08.689Z","comments":true,"path":"2024/05/06/系统架构图/","link":"","permalink":"http://example.com/2024/05/06/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE/","excerpt":"","text":"","categories":[],"tags":[{"name":"技术设计","slug":"技术设计","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1/"}]},{"title":"树形结构数据字典设计","slug":"树形结构数据字典设计","date":"2024-04-28T06:39:04.000Z","updated":"2024-04-28T09:28:28.503Z","comments":true,"path":"2024/04/28/树形结构数据字典设计/","link":"","permalink":"http://example.com/2024/04/28/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"背景最近接受一个小需求，对AI生成的对话记录提供点赞和反馈功能，反馈的内容由后端配置化 分析看到需求第一时间想到的是将反馈内容存入数据字典表，经分析，系统目前的字典表设计最多只支持两级，虽然说勉强可以实现，可是会用到一些硬编码。刚好这段时间也不是很忙，做人还是得有一些追求，于是就有了这张树形结构的数据字典表，通用于多级数据字典，便于后续需求扩展。重点就是在原有的基础上加一个PID字段。 编码1.Dao实现将入参字典类型匹配的字典项作为根节点，查找出根节点下的所有子孙节点，包含根节点本身，这里用到了自关联，因为我的mysql版本过低，不能用mysql自带的递归（WITH RECURSIVE 需要8.0及以上版本） 1234567891011121314151617181920212223242526SELECT d3.* FROM tb_sup_basic_dictitem d1 JOIN tb_sup_basic_dictitem d2 ON d1.id = d2.parent_id JOIN tb_sup_basic_dictitem d3 ON d2.id = d3.parent_id WHERE d1.dict_type = &#x27;mastone_report&#x27; UNION SELECT d2.* FROM tb_sup_basic_dictitem d1 JOIN tb_sup_basic_dictitem d2 ON d1.id = d2.parent_id WHERE d1.dict_type = &#x27;mastone_report&#x27; UNION SELECT d1.* FROM tb_sup_basic_dictitem d1 WHERE d1.dict_type = &#x27;mastone_report&#x27; 2.service实现将以上查询的结果集转成树形结构，也用到了递归 123456789101112131415161718192021222324252627282930313233343536373839404142434445public List&lt;BasicDictitem&gt; getByDictType(String dictType,boolean containSelf) &#123; // 1.查找出根dictType相关的所有字典项 List&lt;BasicDictitem&gt; itemList = basicDictitemMapper.findByDictType(dictType); // 2.将itemList转换成id,dictitem的map Map&lt;Long, BasicDictitem&gt; dictitemMap = itemList.stream() .collect(Collectors.toMap(BasicDictitem::getId, item -&gt; item)); // 3.将itemList转换成Map&lt;Long,List&lt;BasicDictitem&gt;&gt;，其中List&lt;BasicDictitem&gt;是按每个item对象中的parentId分组后的集合 Map&lt;Long, List&lt;BasicDictitem&gt;&gt; childrenMap = itemList.stream().filter(item -&gt; item.getParentId() != null) .collect(Collectors.groupingBy(BasicDictitem::getParentId)); // 4.找到根节点，并从根节点开始遍历，构建子孙节点 List&lt;BasicDictitem&gt; tree = new ArrayList&lt;&gt;(); for (BasicDictitem item : itemList) &#123; if (item.getParentId() == null) &#123; buildTreeRecursive(item, childrenMap); tree.add(item); &#125; &#125; // 6.如果需要包含自身，则添加到树中,默认不包含 if (containSelf)&#123; return tree; &#125; return tree.get(0).getChildren(); &#125; /** * 递归构建子孙节点 * @param parent * @param childrenMap */ private void buildTreeRecursive(BasicDictitem parent, Map&lt;Long, List&lt;BasicDictitem&gt;&gt; childrenMap) &#123; List&lt;BasicDictitem&gt; children = childrenMap.get(parent.getId()); if (children != null) &#123; for (BasicDictitem child : children) &#123; buildTreeRecursive(child, childrenMap); parent.getChildren().add(child); &#125; &#125; &#125; 3.controller实现123456789101112/** * 树形字典项通用接口，字典类型见tb_sup_basic_dictitem表 * @param dictType 字典类型 * @param containSelf 是否包含本身节点 * @return */@GetMapping(&quot;/getByDictType.json&quot;)public YlskResult getByDictType(@RequestParam String dictType, @RequestParam(value = &quot;containSelf&quot;,required=false,defaultValue = &quot;0&quot;)boolean containSelf)&#123; List&lt;BasicDictitem&gt; tree = basicDictitemService.getByDictType(dictType,containSelf); return YlskResult.newSuccess(tree);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&#123; &quot;success&quot;: true, &quot;code&quot;: 1, &quot;data&quot;: [ &#123; &quot;id&quot;: 3, &quot;parentId&quot;: 2, &quot;dictType&quot;: &quot;mastone_report_wrong&quot;, &quot;dictName&quot;: &quot;理解问题有误&quot;, &quot;children&quot;: [ &#123; &quot;id&quot;: 6, &quot;parentId&quot;: 3, &quot;dictType&quot;: &quot;mastone_report_wrong_1&quot;, &quot;dictName&quot;: &quot;没能理解指令&quot;, &quot;children&quot;: [ ] &#125;, &#123; &quot;id&quot;: 7, &quot;parentId&quot;: 3, &quot;dictType&quot;: &quot;mastone_report_wrong_2&quot;, &quot;dictName&quot;: &quot;未发现问题的错误&quot;, &quot;children&quot;: [ ] &#125;, &#123; &quot;id&quot;: 8, &quot;parentId&quot;: 3, &quot;dictType&quot;: &quot;mastone_report_wrong_3&quot;, &quot;dictName&quot;: &quot;无法理解上下文&quot;, &quot;children&quot;: [ ] &#125;, &#123; &quot;id&quot;: 9, &quot;parentId&quot;: 3, &quot;dictType&quot;: &quot;mastone_report_wrong_4&quot;, &quot;dictName&quot;: &quot;答非所问&quot;, &quot;children&quot;: [ ] &#125; ] &#125;, &#123; &quot;id&quot;: 4, &quot;parentId&quot;: 2, &quot;dictType&quot;: &quot;mastone_report_poor&quot;, &quot;dictName&quot;: &quot;回答不佳&quot;, &quot;children&quot;: [ &#123; &quot;id&quot;: 10, &quot;parentId&quot;: 4, &quot;dictType&quot;: &quot;mastone_report_poor_1&quot;, &quot;dictName&quot;: &quot;有事实性错误&quot;, &quot;children&quot;: [ ] &#125;, &#123; &quot;id&quot;: 11, &quot;parentId&quot;: 4, &quot;dictType&quot;: &quot;mastone_report_poor_2&quot;, &quot;dictName&quot;: &quot;回答对我没有帮助&quot;, &quot;children&quot;: [ ] &#125; ] &#125;, &#123; &quot;id&quot;: 5, &quot;parentId&quot;: 2, &quot;dictType&quot;: &quot;mastone_report_harm&quot;, &quot;dictName&quot;: &quot;有害信息&quot;, &quot;children&quot;: [ &#123; &quot;id&quot;: 12, &quot;parentId&quot;: 5, &quot;dictType&quot;: &quot;mastone_report_harm_1&quot;, &quot;dictName&quot;: &quot;敏感/有害信息&quot;, &quot;children&quot;: [ ] &#125;, &#123; &quot;id&quot;: 13, &quot;parentId&quot;: 5, &quot;dictType&quot;: &quot;mastone_report_harm_2&quot;, &quot;dictName&quot;: &quot;存在价值观问题&quot;, &quot;children&quot;: [ ] &#125; ] &#125; ]&#125;","categories":[],"tags":[{"name":"技术设计","slug":"技术设计","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1/"}]},{"title":"UML时序图","slug":"UML时序图","date":"2024-01-19T04:07:49.000Z","updated":"2024-05-28T03:46:58.754Z","comments":true,"path":"2024/01/19/UML时序图/","link":"","permalink":"http://example.com/2024/01/19/UML%E6%97%B6%E5%BA%8F%E5%9B%BE/","excerpt":"","text":"","categories":[],"tags":[{"name":"技术设计","slug":"技术设计","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1/"}]},{"title":"如何画好一张架构图/业务图/流程图，掌握这4个关键点(转载)","slug":"技术设计图掌握4个关键点","date":"2024-01-11T08:39:08.000Z","updated":"2024-05-28T03:44:57.966Z","comments":true,"path":"2024/01/11/技术设计图掌握4个关键点/","link":"","permalink":"http://example.com/2024/01/11/%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%E5%9B%BE%E6%8E%8C%E6%8F%A14%E4%B8%AA%E5%85%B3%E9%94%AE%E7%82%B9/","excerpt":"","text":"原文链接简介： 作为一个开发，日常工作中免不了要画一些图，无论是技术架构图还是业务流程图。基于个人的一些经验，作者分享了他的作图方法，给大家一点思路提供参考，希望在未来的工作、生活中都能有所帮助。 来源｜阿里云开发者公众号 作者｜湘叶 前言今天的分享不是干货，是锦上添花的软技能。作为一个开发，日常工作中免不了要画一些图，无论是技术架构图还是业务流程图。基于个人的一些经验，分享一下我的作图方法，给大家一点思路提供参考，希望在未来的工作、生活中都能有所帮助。 一. 图例1. 代码实现图 2. 技术架构图 3. 业务流程图 4. 技术链路图 5. 交互时序图 Tips：以上图例均用语雀画板创作 二. 好图的定义 结构清晰：观点明确、主次分明、内容清楚 外表美观：有更多的浏览欲&#x2F;阅读欲 内容完整：一张图内容自闭环 三. 关键点如何让图结构更清晰？具有设计感，设计四大原则。如何让图外表更美观？具有美感，色轮的运用、黄金分割。如何让图内容更完整？以终为始的设计，用户为先的思想，信息补全&#x2F;添加标注。 1. 设计感：设计四大原则 亲密性：实现组织性（让有关系的元素挨在一起，有区别的元素分开） 对齐：使页面统一而且有条理（元素与元素之间存在一些对齐效果） 对比：增强页面的效果、有助于信息的组织（元素与元素之间存在一些对比效果） 重复：更统一，增强视觉效果（让类似的元素存在一样的效果&#x2F;样式） 将这些原则应用到图的线、块、面上。 Tips：世界著名设计师罗宾·威廉姆出版过一本畅销书，叫做《写给大家看的设计书》，里面提到了设计四大原则：亲密性、对齐、对比、重复，四大基本原则涵盖了品牌、电商、包装、UI等诸多领域，成为众多设计从业者必须掌握的设计原则。对于非设计的同学，也应该了解一下，提升自己的设计感。 2. 美感：色轮的运用 美术三原色：红黄蓝（在三色场景下，应用最多最广泛的颜色） 互补色：一种作为主色，另一种作为强调（在二色场景下，用互补色） 等距三色组：会让人愉悦的颜色组合（在三色场景下，使用等距三色组具有愉悦感） 采用同层级的颜色：具有和谐感的颜色组合（在多色场景下，采用同层级的颜色更具和谐） Tips：《写给大家看的设计书》里面提到了对颜色的运用，我们要从色轮上找到颜色的运用方法 3. 美感：黄金分割构图法 黄金分割：0.618（图的整体大小采用长1.618宽1的黄金比） 斐波那契数列：1，1，2，3，5，8，13，21，34，55，89……，当趋向于无穷大时，前一项与后一项的比值越来越逼近黄金分割0.618 Tips：黄金分割是指将整体一分为二，较大部分与整体部分的比值等于较小部分与较大部分的比值，其比值约为0.618。黄金比有严格的艺术感、和谐感，蕴藏丰富的美学价值，而且呈现于不少动物和植物的外观。现今普遍很多工业产品、电子产品、建筑物或艺术品均应用了黄金比，使其更美观。 4. 完整感：以终为始的设计 思考先行：以终为始的设计 列出所有要素：所有能帮助看图人理解的元素都要有，包括图例标注、箭头顺序、标题、注解 用户为先：把自己当作看图人，在没有上下文的情况下能获取到图中多少信息 在这里我们要借鉴以终为始的思维模式，在作图前我们要想清楚作这张图的目的是什么，是想要表达清楚什么，以及需要哪些元素，最终实现的效果就是通过一张图，就能完整地了解你的意图和目标。 Tips：史蒂芬·柯维的《高效能人士的七个习惯》中，“以终为始”，是第二个好习惯。“以终为始”是以所有事物都经过两次创造的原则为基础的。所有事物都有心智的，即第一次的创造(mental &#x2F;first creation)，和实际的，即第二次的创造(physical&#x2F;second creation)。我们做任何事都是先在心中构思，然后付诸实现。正因如此，认定使命才显得如此重要。 四. 结语 了解了这4个关键点，再回头看看第一部分的图例，是不是有更好的体感了。最后，4个关键点只是提升你的作图思维，具体XX架构图&#x2F;XX业务图&#x2F;XX流程图&#x2F;XX链路图&#x2F;XX时序图应该怎么画，每个人实操画出来的风格都不一样，就像有的人喜欢黑字白底、有的人喜欢白字黑底、有的人喜欢深色、有的人喜欢浅色等等，但只要遵循亲齐比复四大原则、色轮的运用、黄金分割构图法、以终为始的设计这4个关键点，画出来的图就不会太差，快来试试吧～","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"系统设计的33个黄金法则","slug":"系统设计的33个黄金法则","date":"2024-01-11T08:39:08.000Z","updated":"2024-05-28T03:45:32.717Z","comments":true,"path":"2024/01/11/系统设计的33个黄金法则/","link":"","permalink":"http://example.com/2024/01/11/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%8433%E4%B8%AA%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99/","excerpt":"","text":"对于数据密集型系统 — 考虑使用缓存。 对于写入量大的系统 — 使用消息队列进行异步处理 对于低延迟要求 — 考虑使用缓存和 CDN。 需要𝐀原子性、𝐂一致性、𝐈隔离性、𝐃耐用性兼容数据库 — 选择 RDBMS&#x2F;SQL 数据库。 对于非结构化数据——可以选择NoSQL数据库。 拥有复杂的数据（视频、图像、文件）——选择 Blob&#x2F;对象存储。 复杂的计算——使用消息队列和缓存。 海量数据搜索——考虑搜索索引、尝试搜索引擎。 扩展 SQL 数据库 — 实施数据库分片。 高可用性、性能和吞吐量 — 使用负载均衡器。 全球数据交付——考虑使用 CDN。 图形数据（具有节点、边和关系的数据）——利用图形数据库。 扩展各种组件——实现水平扩展。 高性能数据库查询——使用数据库索引。 批量作业处理——考虑批处理和消息队列。 服务器负载管理和防止 DOS 攻击 - 使用速率限制器。 微服务架构——使用 API 网关。 针对单点故障——实施冗余。 为了容错性和持久性——实施数据复制。 对于用户到用户的快速通信 — 使用 Websockets。 分布式系统中的故障检测——实现心跳。 数据完整性——使用校验和算法。 高效的服务器扩展——一致性哈希。 去中心化数据传输——考虑 Gossip 协议。 基于位置的功能 — 使用四叉树、Geohash 等。 避免特定的技术名称 — 使用通用术语。 高可用性和一致性的权衡——最终一致性。 对于IP解析和域名查询——DNS。 处理网络请求中的大数据——实施分页。 缓存删除策略 — 首选 LRU（最近最少使用）缓存。 处理流量高峰：实现自动扩展以动态管理资源 审计跟踪 — 考虑使用数据湖 处理高并发连接 — 使用连接池并考虑使用 Protobuf 来最小化数据","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Homebrew介绍","slug":"Homebrew介绍","date":"2023-11-24T02:51:53.000Z","updated":"2023-12-01T12:16:05.051Z","comments":true,"path":"2023/11/24/Homebrew介绍/","link":"","permalink":"http://example.com/2023/11/24/Homebrew%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"Homebrew 是 macOS 上的一款包管理工具，用于简化软件的安装和管理。以下是 Homebrew 的基本使用教程： 安装 Homebrew：打开终端（Terminal）并执行以下命令安装 Homebrew： 12bashCopy code/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 这个命令会下载并安装 Homebrew。 使用 Homebrew 安装软件： 安装软件： 使用 Homebrew 安装软件非常简单，只需执行以下命令： 12bashCopy codebrew install &lt;软件名称&gt; 例如，要安装 Git，可以运行： 12bashCopy codebrew install git 更新 Homebrew： 保持 Homebrew 及其软件包是最新的，定期执行以下命令： 12bashCopy codebrew update 卸载软件： 卸载已安装的软件包可以使用 brew uninstall 命令： 12bashCopy codebrew uninstall &lt;软件名称&gt; 查看已安装的软件： 查看已安装的软件列表： 12bashCopy codebrew list 搜索软件包： 想要查找特定软件包是否可用，可以使用 brew search： 12bashCopy codebrew search &lt;关键词&gt; 例如，搜索 Python： 12bashCopy codebrew search python 查看软件信息： 查看软件包的详细信息： 12bashCopy codebrew info &lt;软件名称&gt; 例如，查看 Git 的信息： 12bashCopy codebrew info git 清理不需要的文件： 清理 Homebrew 下载的临时文件和旧版本： 12bashCopy codebrew cleanup 这些是 Homebrew 的基本用法。使用这些命令，你可以方便地安装、更新和管理软件包。在 Homebrew 中，Formulae 和 Casks 分别用于管理两类软件包：命令行工具和图形界面应用。以下是它们的区别： Formulae（公式）： 类型： Formulae 是用于安装命令行工具（通常是不带图形界面的程序）的规范。 安装路径： 安装的命令行工具通常会被放置在 /usr/local/bin 目录下，使其可以通过命令行直接调用。 例子： 安装 Git 或 Python 的命令如下： 123bashCopy codebrew install gitbrew install python Casks（瓶子）： 类型： Casks 用于安装图形界面应用，这些应用通常有用户界面，例如浏览器、编辑器、办公软件等。 安装路径： Casks 安装的应用通常位于 /Applications 目录下，就像你手动安装的应用一样。 例子： 安装 Google Chrome 或 Visual Studio Code 的命令如下： 123bashCopy codebrew install --cask google-chromebrew install --cask visual-studio-code 通过这种方式，Homebrew 提供了一种统一的管理方式，使用户可以方便地通过命令行安装和管理不同类型的软件包。你可以使用 brew install 安装 Formulae，而对于 Casks，你需要使用 brew install --cask。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"hexo个人博客搭建","slug":"hexo个人博客搭建","date":"2023-11-21T03:06:46.000Z","updated":"2023-11-27T02:47:03.035Z","comments":true,"path":"2023/11/21/hexo个人博客搭建/","link":"","permalink":"http://example.com/2023/11/21/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"为什么要搭建个人博客 俗话说：“好记性不如烂笔头” 记录在本地磁盘痛点：检索困难、容易丢失、分类归档体验差等 记录在第三方平台（简书、CSDN、掘金）痛点：UI界面丑、有违规风险、账号密码记不住等 搭建个人博客工具调研 WordPress是一款强大的内容管理系统，适合非技术用户，有大量主题和插件。但可能需要更多资源，对定制性有一定限制。 Jekyll和Hugo是静态网站生成器，生成速度快，安全性高。Jekyll基于Ruby，Hugo基于Go，两者都适合技术用户，但Jekyll在大型项目中可能较慢，而Hugo则更快。 Hexo是基于Node.js的静态博客生成器，简单易用，生成速度快，适合追求速度和轻量级的用户。然而，相比Jekyll和Hugo，Hexo的生态相对较小。 Hexo环境准备 Node.js和npm：在Node.js官网下载最新版本的Node.js安装包，并按照安装向导进行安装。Node.js会自动包含npm。 1234~ node -vv14.20.1~ npm -v6.14.17 Git：在Git官网下载最新版本的Git安装包，按照安装向导进行安装。Git是Hexo用于版本控制的工具。 12~ git --versiongit version 2.32.1 (Apple Git-133) 搭建步骤 安装Hexo： 打开命令行或终端，运行以下命令安装Hexo： 1npm install -g hexo-cli 创建博客： 在你希望创建博客的文件夹内，运行以下命令初始化Hexo博客： 1hexo init myblog 进入博客目录： 1cd myblog 安装依赖： 1npm install 启动本地服务器： 1hexo server 在浏览器中访问 http://localhost:4000，你将能够看到正在搭建的博客。 选择主题： Hexo支持许多主题，你可以在Hexo官方主题列表中选择一个你喜欢的主题，并按照主题文档进行安装和配置。 这里选择：https://github.com/leedom92/hexo-theme-leedom 1npm i hexo-theme-leedom 在根目录下的_config.yml文件中修改主题的配置 12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/##theme: puretheme: leedom 重新构建，焕然一新 12hexo cleanhexo s 编写文章： 在 source/_posts 目录下创建Markdown文件，写下你的文章内容。 生成静态文件： 12bashCopy codehexo generate 这会在 public 目录下生成最终的静态文件。 部署博客： 如果你想将博客部署到GitHub等平台，按照相应平台的配置和Hexo文档中的部署章节进行操作。 安装 Hexo 的 GitHub 部署插件： 1npm install hexo-deployer-git --save 在 _config.yml 中配置 GitHub Pages 部署信息： 1234deploy: type: git repo: https://github.com/username/username.github.io.git branch: master 运行以下命令将 Hexo 站点部署到 GitHub Pages： 123hexo clean hexo generatehexo deploy hexo常用命令： 1234567891011121314# 1.初始化博客hexo init &lt;folder&gt;# 2.启动本地服务器hexo server# 3.创建新文章hexo new &lt;title&gt;# 4.生成静态文件hexo generate# 5.部署博客hexo deploy# 6.清理缓存hexo clean# 7.查看帮助hexo --help","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"我与ChatGPT的日常对话","slug":"我与ChatGpt的日常对话","date":"2023-11-15T16:00:00.000Z","updated":"2023-11-16T08:07:50.494Z","comments":true,"path":"2023/11/16/我与ChatGpt的日常对话/","link":"","permalink":"http://example.com/2023/11/16/%E6%88%91%E4%B8%8EChatGpt%E7%9A%84%E6%97%A5%E5%B8%B8%E5%AF%B9%E8%AF%9D/","excerpt":"","text":"","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"日常coding笔记","slug":"日常coding笔记","date":"2023-11-14T16:00:00.000Z","updated":"2024-07-10T11:41:43.482Z","comments":true,"path":"2023/11/15/日常coding笔记/","link":"","permalink":"http://example.com/2023/11/15/%E6%97%A5%E5%B8%B8coding%E7%AC%94%E8%AE%B0/","excerpt":"","text":"代码标准：简洁、易读、易扩展 1.填充客户列表「是否已经添加计划」标签1234567891011private void loadAddPlanLabel(List&lt;VisitCustInfo&gt; resultList, Long supUserId, String planTime) &#123; List&lt;String&gt; custIds = resultList.stream().map(VisitCustInfo::getCustId).collect(Collectors.toList()); Map&lt;String,VisitCustInfo&gt; map = resultList.stream() .collect(Collectors.toMap(VisitCustInfo::getCustId,item -&gt; item)); List&lt;String&gt; addPlanCustIds = custVisitMapper.findVistPlan(custIds,supUserId,planTime); if (!CollectionUtils.isEmpty(addPlanCustIds)) &#123; addPlanCustIds.stream().forEach(custId -&gt; &#123; map.get(custId).setAddDayPlan(true); &#125;); &#125; &#125; 2.填充客户列表「当月已拜访次数」标签1234567891011private void loadVisitCountLabel(List&lt;VisitCustInfo&gt; resultList, Long supUserId) &#123; List&lt;String&gt; custIds = resultList.stream().map(VisitCustInfo::getCustId).collect(Collectors.toList()); Map&lt;String,VisitCustInfo&gt; map = resultList.stream() .collect(Collectors.toMap(VisitCustInfo::getCustId,item -&gt; item)); List&lt;VisitCustInfo&gt; visitedCustList = custVisitMapper.findVistCount(custIds,supUserId); if (!CollectionUtils.isEmpty(visitedCustList))&#123; visitedCustList.stream().forEach(visitCustInfo -&gt; &#123; map.get(visitCustInfo.getCustId()).setVisitCountCurMonth(visitCustInfo.getVisitCountCurMonth()); &#125;); &#125; &#125; 3.批量更新Update Select…..1234567891011UPDATE tb_cust_main tcmJOIN ( SELECT tcm.cust_id, tec.link_man AS erplinkman, tec.link_phone AS erplinkphone FROM tb_cust_main tcm INNER JOIN tb_cust_relation tcr ON tcm.cust_id = tcr.cust_id INNER JOIN tb_erp_cust tec ON tcr.store_cust_no = tec.erp_cust_no WHERE tcr.store_id = 1735134917792903169 AND tcm.legal_person_tel LIKE &#x27;Ylsk%&#x27; AND tec.link_phone NOT LIKE &#x27;Ylsk%&#x27;) erpcust ON tcm.cust_id = erpcust.cust_idSET tcm.legal_person = erpcust.erplinkman, tcm.legal_person_tel = erpcust.erplinkphone; 4.对集合做统计分析12345678// 管理者身份下的团队或部门下的业务员分享明细List&lt;ScienceShareUserVo&gt; shareUserList = shareMapper.findShareUserList4Manager(scienceId,scienceQo.getSupAccountId());// 统计分享用户数Long shareUserCount = shareUserList.stream().filter(item -&gt; item.getIsShare() == 1).collect(Collectors.counting());// 统计查看客户数int viewCount = shareUserList.stream().mapToInt(item -&gt; item.getViewCount().equals(&quot;-&quot;) ? 0 : Integer.valueOf(item.getViewCount())).sum();// 统计报名客户数int attendorCount = shareUserList.stream().mapToInt(item -&gt; item.getAttendorCount().equals(&quot;-&quot;) ? 0 : Integer.valueOf(item.getAttendorCount())).sum(); 5.mysql UNION 和 UNION ALL 的区别UNION:相同的行去重UNION ALL ：相同的行不去重，由于没有去重的计算，性能优于UNION 6.insert into select …..12345678910111213141516171819202122232425insert into tb_sup_report_merssage (prod_no,sup_user_id,message_type,message_content,supplier_id,batch_number) SELECT tsres.store_prod_no, tssi.sup_user_id, 10, concat(tsres.prod_name,&#x27;等商品即将过期，请马上处理&#x27;) , tsres.supplier_id, tsres.batch_number FROM tb_sup_report_expiration_soon tsres JOIN tb_sup_salesman_info tssi ON tssi.supplier_id = tsres.supplier_id AND tssi.employee_type = 1 and tsres.create_at &gt; DATE_ADD(CURDATE(), INTERVAL -7 day) WHERE NOT EXISTS ( SELECT 1 FROM tb_sup_report_merssage tsrm WHERE tsrm.sup_user_id = tssi.sup_user_id AND tsrm.prod_no = tsres.store_prod_no AND tsrm.batch_number = tsres.batch_number and tsrm.message_type = 10 ) 7.insert into on duplicate key updat…..123456789101112131415161718192021222324252627282930313233343536&lt;insert id=&quot;batchSaveOrUpdate&quot;&gt; insert into tb_sup_report_expiration_soon ( store_prod_no, prod_name, prod_specification, bigpackage_quantity, store_no, owner_id, supplier_id, erp_no, batch_number, production_date, validtime, `storage` ) values &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt; ( #&#123;item.storeProdNo&#125;, #&#123;item.prodName&#125;, #&#123;item.prodSpecification&#125;, #&#123;item.bigpackageQuantity&#125;, #&#123;item.storeNo&#125;, #&#123;item.ownerId&#125;, #&#123;item.supplierId&#125;, #&#123;item.erpNo&#125;, #&#123;item.batchNumber&#125;, #&#123;item.productionDate&#125;, #&#123;item.validtime&#125;, #&#123;item.storage&#125; ) &lt;/foreach&gt; on duplicate key update bigpackage_quantity = values(bigpackage_quantity), storage = values(storage) &lt;/insert&gt; 8.找出两个对象集合中的差异部分第一步：先重写对象的equals方法(默认情况下，equals 方法会比较对象的内存地址，即只有当两个对象的引用相同时才会返回 true。如果是用到lombok插件的Data注解，则默认会根据对象的成员变量值重写equals) 1234567891011121314151617181920public class TargetUserQo &#123; String supUserId; String linkMan; List&lt;String&gt; data; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; TargetUserQo that = (TargetUserQo) o; return Objects.equals(supUserId, that.supUserId) &amp;&amp; Objects.equals(linkMan, that.linkMan); &#125; @Override public int hashCode() &#123; return Objects.hash(supUserId, linkMan); &#125;&#125; 第二步：利用stream()求差异 12345678910// 1.导入的用户列表List&lt;TargetUserQo&gt; importUsers = targetUserImportQo.getUserList();// 2.有效的用户列表List&lt;TargetUserQo&gt; validUsers = targetService.importCheck(targetUserImportQo);// 3.无效的用户列表，即importUsers 和 validUsers 的差异List&lt;TargetUserQo&gt; invalidUsers = importUsers.stream() .filter(user -&gt; !validUsers.contains(user)) .collect(Collectors.toList()); 9.一对多关系表，统计分析以“一”表的维度查询，对“多”表的数据做统计 1234567891011121314151617181920212223242526272829SELECT tssi.sup_user_id, -- 授信业务员id tsa.link_man, -- 授信业务员名称 tsbb.supplier_name, -- 所属团队 tssi.credit_status,-- 授信状态 COUNT(tscc.cust_id) AS creditCustCount, -- 授信客户数 ifnull(SUM(tscbr.accounting_amount),0) AS creditBillAmountTotal, -- 授信订单金额 count(distinct(CASE WHEN tscbr.accounting_status = 1 THEN tscbr.cust_id END)) as repaymentingCustCount, -- 待回款客户数 IFNULL(SUM(CASE WHEN tscbr.accounting_status = 1 THEN tscbr.accounting_amount END), 0) AS repaymentingAmountTotal, -- 待回款订单金额 count(distinct(CASE WHEN tscbr.accounting_status = 1 and tscbr.plan_repayment_time &lt; CURDATE() THEN tscbr.cust_id END)) as expireCustCount,-- 逾期客户数 IFNULL(SUM(CASE WHEN tscbr.accounting_status = 1 and tscbr.plan_repayment_time &lt; CURDATE() THEN tscbr.accounting_amount END), 0) AS expireAmountTotal -- 逾期订单金额 FROM tb_sup_salesman_info tssi LEFT JOIN tb_sup_user tsu ON tsu.sup_user_id = tssi.sup_user_id LEFT JOIN tb_sup_account tsa ON tsa.sup_account_id = tsu.sup_account_id LEFT JOIN tb_sup_b2b tsbb ON tssi.supplier_id = tsbb.supplier_id LEFT JOIN tb_sup_credit_config tscc ON tscc.sup_user_id = tssi.sup_user_id AND tscc.responsible_party_type = 1 LEFT JOIN tb_sup_credit_bill_record tscbr ON tscbr.sup_user_id = tssi.sup_user_id and tscc.cust_id = tscbr.cust_id AND tscbr.responsible_party_type = 1 WHERE tssi.is_credited = 1 AND tsbb.supplier_category = 2 AND tssi.supplier_id IN (&#x27;117&#x27;, &#x27;176&#x27;, &#x27;177&#x27;, &#x27;181&#x27;) GROUP BY tssi.sup_user_id","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Bug等级划分","slug":"Bug等级划分","date":"2023-10-30T16:00:00.000Z","updated":"2023-10-31T03:38:30.439Z","comments":true,"path":"2023/10/31/Bug等级划分/","link":"","permalink":"http://example.com/2023/10/31/Bug%E7%AD%89%E7%BA%A7%E5%88%92%E5%88%86/","excerpt":"","text":"软件Bug的来源Bug，原意为虫子，现在通常指软件缺陷、故障、问题等。 第一代计算机是由许多庞大且昂贵的继电器组成，并利用大量的电力来使继电器工作。可能正是由于计算机运行产生的光和热，引得一只小虫子Bug钻进了一支继电器内，导致整个计算机无法工作。 研究人员费了半天时间，总算发现原因所在，把这只小虫子从继电器中取出后，计算机又恢复正常。后来，Bug这个名词就沿用下来，表示电脑系统或程序中隐藏的错误、缺陷，漏洞或问题。 软件Bug的等级软件bug一般分为四种或五种等级，不同的软件领域，划分的可能略有差异，但大同小异。 一级（致命）Bug 通常表现为：主流程无法跑通，系统无法运行，崩溃或严重资源不足，应用模块无法启动或异常退出，主要功能模块无法使用。 比如： 1.内存泄漏； 2.严重的数值计算错误； 3.系统容易崩溃； 4.功能设计与需求严重不符； 5.系统无法登陆； 6.循坏报错，无法正常退出。 二级（严重）Bug通常表现为：影响系统功能或操作，主要功能存在严重缺陷，但不会影响到系统稳定性。 比如：1.功能未实现；2.功能存在报错；3.数值轻微的计算错误。 三级（一般）Bug通常表现为：界面、性能缺陷。 比如：1.边界条件下错误；2.容错性不好；3.大数据下容易无响应；4.大数据操作时，没有提供进度条。 四级（提示）Bug通常表现为：易用性及建议性问题比如：1.界面颜色搭配不好；2.文字排列不整齐；3.出现错别字，但是不影响功能；4.界面格式不规范。","categories":[],"tags":[{"name":"项目管理","slug":"项目管理","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]},{"title":"中国历史朝代纪年表","slug":"中国历史朝代纪年表","date":"2023-10-30T16:00:00.000Z","updated":"2023-12-07T03:15:27.495Z","comments":true,"path":"2023/10/31/中国历史朝代纪年表/","link":"","permalink":"http://example.com/2023/10/31/%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E6%9C%9D%E4%BB%A3%E7%BA%AA%E5%B9%B4%E8%A1%A8/","excerpt":"","text":"中国朝代顺口溜三皇五帝夏商周，春秋战国乱悠悠。秦汉三国东西晋，南朝北朝是对头。隋唐五代又十国，宋元明清帝王休。 中国历代皇帝顺序表秦朝(公元前221 - 207年)秦始皇嬴政、秦二世胡亥、秦三世子婴。 西汉(公元前202 – 公元8年)汉高祖刘邦、汉惠帝刘盈、汉文帝刘恒、汉景帝刘启、汉武帝刘彻、汉昭帝刘弗陵、汉宣帝刘淘、汉元帝刘奭、汉成帝刘蔫、汉哀帝刘欣、汉平帝刘行、孺子婴(王莽摄政)。 东汉(25 - 220年)光武帝刘秀、汉明帝刘庄、汉章帝刘炟、汉和帝刘肇、汉殇帝刘隆、汉安帝刘祜、汉顺帝刘保、汉冲帝刘炳、汉质帝刘赞、汉桓帝刘志、汉灵帝刘宏、汉献帝刘协。 三国(220 - 265年)魏国: 魏文帝曹丕、魏明帝曹叡、魏齐王曹芳、高贵乡公曹髦、魏元帝曹奂 蜀国: 昭烈帝刘备、后主刘禅 吴国: 武烈帝孙坚、长沙桓王孙策、吴大帝孙权、吴会稽王孙亮、吴景帝孙休、吴乌程侯孙皓晋 西晋(265 - 317年)晋武帝司马炎、晋惠帝司马衷、晋怀帝司马炽、晋愍帝司马邺。 东晋(317 - 420年)晋元帝司马睿、晋明帝司马绍、晋成帝司马衍、晋康帝司马岳、晋穆帝司马聘、晋哀帝司马丕、海西公司马奕、简文帝司马昱、孝武帝司马窑、晋安帝司马德宗、晋恭帝司马德文。 北朝(386年 - 581年)北魏: 道武帝拓跋珪、明元帝拓跋嗣、太武帝拓跋焘、南安王拓跋余、文成帝拓跋浚、献文帝拓跋弘、孝文帝元宏、宣武帝元恪、孝明帝元诩、幼主元钊、孝庄帝元子攸、长广王元晔、节闵帝元恭、安定王元朗、孝武帝元惰 东魏: 孝静帝元善见 西魏: 文帝元宝炬、废帝元钦、恭帝拓跋廓 北齐: 神武帝高欢、文襄帝高澄、文宣帝高洋、废帝高殷、孝昭帝高演、武成帝高湛、后主高纬、安德王高延宗、幼主高恒、范阳王高绍义 北周: 文帝宇文泰、孝闵帝宇文觉、明帝宇文毓、武帝宇文邕、宣帝宇文赞、静帝宇文衍 南朝(420 - 589年)宋: 宋武帝刘裕、宋少帝刘义符、宋文帝刘义隆、宋孝武帝刘骏、宋前废帝刘子业、宋明帝刘或、宋后废帝刘昱、宋顺帝刘准 齐(萧齐): 齐高帝萧道成、齐武帝萧赜、齐明帝萧鸾、东昏侯萧宝、齐和帝萧宝融 梁(萧梁): 梁武帝萧衍、简文帝萧纲、梁文帝萧绎、梁晋帝萧方智 陈(南陈): 陈武帝陈霸先、陈文帝陈蓓、陈废帝陈伯宗、陈宣宗陈顼、陈后主陈叔宝 隋朝(581 - 618年)隋文帝杨坚、隋炀帝杨广、隋恭帝杨侑 唐朝(618 - 907年)唐高祖李渊、唐太宗李世民、唐高宗李治、武后武则天（武瞾)、唐中宗李显、唐睿宗李旦、唐玄宗李隆基、唐肃宗李享、唐代宗李豫、唐德宗李适、唐顺宗李涌、唐宪宗李纯、唐穆宗李恒、唐敬宗李湛、唐文宗李昂、唐武宗李炎、唐宣宗李忱、唐懿宗李准、唐僖宗李儇、唐昭宗李晔、唐哀帝李祝。 北宋(960 - 1127年)宋太祖赵匡胤、宋太宗赵匡义、宋真宗赵恒、宋仁宗赵祯、宋英宗赵曙、宋神宗赵顼、宋哲宗赵煦、宋徽宗赵佶、宋钦宗赵桓。 南宋(1127 - 1276年)宋高宗赵构、宋孝宗赵音、宋光宗赵惇、宋宁宗赵扩、宋理宗赵昀、宋度宗赵樭、宋恭帝赵显。 元朝(1260 - 1368年)元世祖忽必烈、元成宗、元武宗、元仁宗、元英宗、元泰定帝、元天顺帝、元文宗、元明宗、元宁宗、元顺帝。 明朝(1368 - 1644年)明太祖朱元璋、明惠帝朱允炆、明成祖朱棣、明仁宗朱高炽、明宣宗朱瞻基、明英宗朱祁镇、明代宗朱祁钰、明英宗朱祁镇、明宪宗朱见深、明孝宗朱祐搅、明武宗朱厚娥、明世宗朱厚燎、明穆宗朱载屋、明神宗朱翊钧、明光宗朱常洛、明熹宗朱由校、明思宗朱由检。 清朝(1616 - 1912年)清太祖努尔哈赤、清太宗皇太极、清世祖顺治福临、清圣祖康熙玄烨、清世宗雍正胤慎、清高宗乾隆弘历、清仁宗嘉庆顒琰、清宣宗道光旻宁、清文宗咸丰奕、清穆宗同治载淳、清德宗光绪载恬、清宣统帝溥仪。","categories":[],"tags":[{"name":"历史","slug":"历史","permalink":"http://example.com/tags/%E5%8E%86%E5%8F%B2/"}]},{"title":"浅谈技术负债","slug":"浅谈技术负债","date":"2023-10-29T16:00:00.000Z","updated":"2024-05-28T03:42:52.124Z","comments":true,"path":"2023/10/30/浅谈技术负债/","link":"","permalink":"http://example.com/2023/10/30/%E6%B5%85%E8%B0%88%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA/","excerpt":"","text":"何为技术债务技术债务：是指在软件开发过程中，为了快速交付产品或功能而采取的技术上的妥协或权衡。它类似于财务债务，是对未来付出代价的承诺。技术债务可以包括未完成的功能、低质量的代码、技术陈旧或过时、缺乏文档和测试覆盖等。这些债务会增加软件系统的复杂性、降低可维护性，并增加未来开发和维护的成本。与财务债务类似，技术债务也需要及时偿还，以确保软件系统的质量和可持续性。技术团队通常会努力减少技术债务，并在合适的时机进行技术债务的还清和重构。 技术债务如何偿还技术债务的偿还是一个重要的过程，它有助于改善软件系统的质量和可维护性。以下是一些常见的技术债务偿还策略： 重构代码：通过重构低质量的代码，改善其可读性、可维护性和性能。这包括使用最佳实践和设计模式来优化代码结构和逻辑。 添加测试覆盖：为没有足够测试覆盖的代码编写单元测试、集成测试和端到端测试。这样可以更好地保证代码的正确性和稳定性。 更新技术栈：评估和更新过时的技术和工具，以提高系统的性能、安全性和可维护性。这可能涉及到升级框架、库和依赖项，以及采用新的开发实践和工具。 改进文档和注释：完善代码的文档和注释，使其更易于理解和维护。这有助于新的开发人员快速上手，并减少未来开发的困惑和错误。 优化性能：识别并解决系统中的性能问题，包括减少响应时间、提高并发处理能力和优化资源利用率。 追踪技术债务：建立技术债务的追踪和管理机制，以确保它们得到适时的关注和处理。这可以通过使用专门的工具或集成到项目管理工具中来实现。 需要注意的是，技术债务的偿还需要权衡时间、资源和优先级。团队应该根据项目的需求和优先级，制定合理的计划和策略来偿还技术债务，以最大程度地提高软件系统的质量和可持续性。 我在项目中如何管理技术债 利用JIRA来记录技术债： JIRA中新建任务类型：技术债务 （业务代码）业务小组通过在迭代过程中发现并记录到Jira backlog中 （基础组件）架构小组至少每个月主动去cod review一次以上，发现并记录到Jira backlog中 分析并评估backlog中每个技术债的优先级和工时 产品迭代过程中，评估下个版本业务需求范围时，适当地、合理地安排工期短、优先级高的技术债纳入版本范围，并全员宣讲，每日站会跟进 对于中低优先级的技术债，以月或季为纬度，单独建立冲刺，临时成立研发+测试小组，利用空档时间来处理，每周周会跟进","categories":[],"tags":[{"name":"项目管理","slug":"项目管理","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}]},{"title":"JVM知识点","slug":"JVM知识点","date":"2023-10-26T16:00:00.000Z","updated":"2024-05-28T03:46:24.917Z","comments":true,"path":"2023/10/27/JVM知识点/","link":"","permalink":"http://example.com/2023/10/27/JVM%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1.JVM的区域划分 程序计数器（Program Counter）：线程私有，程序计数器是一块较小的内存区域，它保存着当前线程执行的字节码指令的地址。在线程切换时，程序计数器用于恢复执行的位置。 Java 虚拟机栈（Java Virtual Machine Stack）：线程私有，每个线程在运行时都会创建一个对应的虚拟机栈，用于存储方法的局部变量、操作数栈、动态链接、方法出口等信息。虚拟机栈的大小可以通过 -Xss 参数进行调整。 本地方法栈（Native Method Stack）：线程私有，本地方法栈与虚拟机栈类似，但是它为本地方法（Native Method）服务。本地方法是使用其他语言（如 C&#x2F;C++）编写的方法，通过 JNI（Java Native Interface）与 Java 程序进行交互。 Java 堆（Java Heap）：线程共享，Java 堆是 Java 程序运行时创建的对象的存储区域。它是垃圾回收的主要区域，包括新生代和老年代 新生代（Young Generation）：新生代是 Java 堆的一部分，用于存储新创建的对象。新生代通常被划分为 Eden 空间和两个 Survivor 空间（From 和 To）。大部分对象在新生代被创建和销毁。 老年代（Old Generation）：老年代用于存储生命周期较长的对象。经过多次垃圾回收后仍然存活的对象会被转移到老年代。老年代的空间通常较大。 方法区（Method Area）：线程共享，方法区用于存储类的结构信息（如类名、方法名、字段名）、静态变量、常量池等。在 JDK 1.8 中，方法区被移除，取而代之的是元空间（Metaspace）。 元空间（Metaspace）：线程共享，元空间取代了 JDK 1.8 之前的永久代（Permanent Generation）。元空间用于存储类的元数据信息，包括类的结构、方法、字段、常量池等。元空间的大小默认是不受限制的，但受到操作系统的限制。 以上是 java 8 的内存区域划分。需要注意的是，不同版本的 JDK 可能会有细微的差异，特别是在垃圾回收和内存管理方面 2.堆的区域划分在 Java 的堆（Heap）内存中，可以进一步划分为以下几个区域： 新生代（Young Generation）：新生代是堆内存中的一部分，用于存储新创建的对象。新生代可以进一步划分为 Eden 空间和两个 Survivor 空间（通常称为 From 和 To 空间） Eden(伊甸园) 空间：Eden 空间是新对象的初始分配区域。当 Eden 空间满时，触发一次 Minor GC（Young GC） Survivor(幸存者) 空间：Survivor 空间是用于存放在 Minor GC 过程中幸存下来的对象。在每次 Minor GC 后，仍然存活的对象会被复制到 Survivor 空间中的一个空闲区域。而上一次 GC 时的 Survivor 空间则会被清空 老年代（Old Generation）：老年代是存放经过多次 Minor GC 后仍然存活的对象的区域。老年代的对象一般具有较长的生命周期。当老年代空间不足时，会触发一次 Major GC（Full GC） 元数据区（Metaspace）：元数据区是用于存储类的元数据信息，包括类的结构、方法、字段、常量池等。在较新的 JDK 版本中，元数据区取代了传统的永久代（Permanent Generation）。元数据区的大小默认是不受限制的，但受到操作系统的限制 大对象区域（Large Object Space）：大对象区域是专门用于存储较大的对象，避免在新生代和老年代中频繁进行内存拷贝。一般情况下，大对象直接分配在大对象区域 需要注意的是，堆内存的划分可能会因为不同的垃圾回收器（Garbage Collector）策略而有所不同。不同的垃圾回收器在堆内存划分和对象分配上有不同的优化方式。 3.java的局部变量、成员变量、静态变量、类、对象等内存是如何分配的在 Java 中，局部变量、成员变量、静态变量、类和对象的内存分配如下： 局部变量（Local Variables）：局部变量是在方法、构造器或代码块内部定义的变量。它们在方法被调用时创建，并在方法执行结束后销毁。局部变量的内存分配在栈（Stack）上进行，存储在栈帧（Stack Frame）中。 成员变量（Instance Variables）：成员变量是在类中定义的变量，属于类的实例。每个类的实例都有自己的成员变量副本。成员变量的内存分配在堆（Heap）上进行，当创建对象时，会为每个实例分配一块堆内存来存储成员变量。 静态变量（Static Variables）：静态变量是在类中定义的使用 static 修饰的变量，属于类本身而不是类的实例。静态变量的内存分配在方法区（Method Area）中，它们在程序启动时初始化，并在整个程序运行期间存在。 类（Class）：类的定义在方法区中，包括类的结构、字段、方法和字节码等信息。类的信息在程序加载时被加载到方法区中，并在整个程序运行期间存在。 对象（Objects）：对象是类的实例化，每个对象都有自己的一块堆内存空间来存储实例变量。对象的内存分配在堆上进行，当使用关键字 new 创建对象时，会在堆中分配一块连续的内存空间来存储对象的实例变量。 需要注意的是，局部变量和方法参数在方法调用结束后会被销毁，而成员变量和静态变量的生命周期与对象和类的生命周期相关。 4.JVM的垃圾回收机制是怎样的JVM（Java虚拟机）的垃圾回收机制是自动管理和释放内存的一种机制，用于回收不再使用的对象，以提供更多的可用内存空间。 垃圾回收机制的基本原理是通过标记和清除（Mark and Sweep）的过程来确定哪些对象可以被回收。以下是垃圾回收机制的主要步骤： 标记（Marking）：从根对象（如堆栈中的局部变量和静态变量）开始，递归地遍历所有可访问的对象，并将它们标记为“活动”对象。未被标记的对象即为“垃圾”对象。 清除（Sweeping）：在标记完成后，垃圾回收器会扫描整个堆内存，将未被标记的对象释放，并回收它们占用的内存空间。被标记的对象将保留下来，用于后续的内存分配。 压缩（Compacting）：在清除阶段之后，为了提高内存的连续性和空间利用率，一些垃圾回收器还会执行内存压缩操作。压缩过程会将存活的对象紧凑地移动到堆的一端，以便在另一端释放更多的连续内存空间。 垃圾回收机制的具体实现可以有多种算法和策略，如标记-清除算法、复制算法、标记-整理算法等。不同的垃圾回收器（如Serial、Parallel、CMS、G1等）使用不同的算法和策略，以适应不同的应用场景和性能需求。 通过垃圾回收机制，Java程序可以更方便地管理内存，避免显式地进行内存释放操作，减少内存泄漏和内存溢出的风险。 5. oracle jdk 1.8.0_321 触发垃圾回收的时机在 Oracle JDK 1.8.0_321（Java 8 Update 321）中，垃圾回收的时机是由 JVM（Java虚拟机）自动管理的，我们无法直接触发垃圾回收。 JVM 使用了一种称为 “自适应垃圾回收” 的策略来判断何时执行垃圾回收操作。它基于以下几个因素来决定是否触发垃圾回收： 堆内存的使用情况：当堆内存中的对象达到一定的阈值时，JVM 可能会触发垃圾回收来释放不再使用的对象。 内存分配速率：JVM 会监控对象的分配速率。如果分配速率过高，可能导致堆内存快速填满，JVM 可能会触发垃圾回收来释放不再使用的对象。 系统资源：JVM 还会考虑系统的资源情况，如 CPU 使用率和可用内存等。如果系统资源紧张，JVM 可能会触发垃圾回收来释放内存资源。 请注意，以上是一些触发垃圾回收的常见因素，具体的策略可能会因 JVM 的版本和配置而有所不同。此外，我们也可以通过一些参数来调整垃圾回收的行为，例如 -XX:MaxGCPauseMillis 参数可以指定最大垃圾回收停顿时间。 总之，在 Oracle JDK 1.8.0_321 中，垃圾回收的时机是由 JVM 自动管理的，基于堆内存使用情况、内存分配速率和系统资源等因素来判断何时执行垃圾回收操作。 6.什么场景下会触发新生代的垃圾回收新生代的垃圾回收是由 JVM（Java虚拟机）自动触发的，通常在以下情况下会触发年轻代的垃圾回收： Minor GC（部分垃圾回收）：当新对象被分配到年轻代时，如果年轻代空间不足，JVM 会触发 Minor GC。Minor GC 主要清理年轻代中不再使用的对象，以释放空间供新对象使用。 对象年龄达到阈值：年轻代中的对象会根据其存活时间进行年龄计数。当对象经过多次 Minor GC 后仍然存活，并且达到一定的年龄阈值时，JVM 会将这些对象晋升到老年代。晋升到老年代的过程也会触发年轻代的垃圾回收。 空间分配担保失败：在进行 Minor GC 时，如果存活对象太多，导致年轻代无法容纳所有存活对象，JVM 可能会进行一次 Full GC（完全垃圾回收）。在 Full GC 之前，为了确保空间分配的安全性，JVM 会先触发一次年轻代的垃圾回收。 请注意，年轻代的垃圾回收是 JVM 内部自动管理的过程，我们无法直接触发或控制。JVM 根据对象的生命周期和内存分配情况来判断何时进行垃圾回收操作。 7.什么场景下会触发老年代的垃圾回收老年代的垃圾回收是由 JVM（Java虚拟机）自动触发的，通常在以下情况下会触发老年代的垃圾回收： Major GC（完全垃圾回收）：当老年代空间不足时，JVM 会触发 Major GC。Major GC 主要清理老年代中不再使用的对象，以释放空间供新对象使用。 晋升担保失败：在进行 Minor GC 时，如果存活对象太多，导致老年代无法容纳所有存活对象，JVM 可能会进行一次 Full GC（完全垃圾回收）。在 Full GC 之前，JVM 会先触发一次老年代的垃圾回收，以尽量减少 Full GC 的频率。 显式调用 System.gc()：尽管不建议显式调用 System.gc() 方法，但在某些情况下，我们可能会手动触发垃圾回收。当调用 System.gc() 方法时，JVM 可能会同时触发年轻代和老年代的垃圾回收。 需要注意的是，老年代的垃圾回收相对较少发生，因为老年代中的对象通常具有较长的生命周期。JVM 会根据对象的存活时间和内存分配情况来判断何时进行垃圾回收操作。 请注意，我们通常不建议频繁地手动触发垃圾回收，因为 JVM 在内部已经有自动的垃圾回收机制来管理内存。频繁的垃圾回收可能会导致性能下降，应该根据具体情况进行调优和配置。 8.对象的存活时间对象的存活时间是指对象从被创建到被垃圾回收之间的时间段。在 Java 中，对象的存活时间可以分为以下几种情况： 瞬时对象（Transient Objects）：瞬时对象是指那些在方法中创建并在方法执行结束后立即被销毁的对象。它们的存活时间非常短暂，仅在方法的生命周期内存在。 局部对象（Local Objects）：局部对象是在方法中定义的对象，它们的作用域仅限于方法内部。当方法执行结束后，局部对象会被销毁，它们的存活时间与方法的执行时间相对应。 成员对象（Member Objects）：成员对象是在类中定义的对象，它们的生命周期与类的实例相关。当类的实例不再被引用时，成员对象会随着实例一起被垃圾回收。 静态对象（Static Objects）：静态对象是在类中定义的 static 修饰的对象，它们的生命周期与类的生命周期相同。静态对象在程序运行期间一直存在，直到程序结束或类被卸载时才会被垃圾回收。 长生命周期对象（Long-lived Objects）：长生命周期对象是指存活时间较长的对象，它们通常分配在老年代。这些对象可能是全局缓存、持久化对象等，它们的存活时间可能会跨越多个方法调用或甚至整个应用程序的生命周期。 需要注意的是，对象的存活时间由 JVM 内部的垃圾回收算法和内存分配策略来决定。JVM 会根据对象的引用关系、内存分配情况以及垃圾回收的算法来判断对象的存活时间，并相应地进行垃圾回收。 9.oracle jdk 1.8.0_321 的参数设置在 Oracle JDK 1.8.0_321 中，有许多参数可以用来调整 JVM（Java虚拟机）的行为。以下是一些常见的参数及其解释，包括一些示例： -Xmx&lt;size&gt;：设置最大堆内存大小。&lt;size&gt; 是以字节为单位的整数值，或者带有 g 或 G 后缀的以 GB 为单位的整数值。例如，-Xmx2g 表示将最大堆内存设置为 2 GB。 -Xms&lt;size&gt;：设置初始堆内存大小。&lt;size&gt; 的格式和单位与 -Xmx 参数相同。例如，-Xms512m 表示将初始堆内存设置为 512 MB。 -Xmn&lt;size&gt;：设置年轻代的大小。&lt;size&gt; 的格式和单位与 -Xmx 参数相同。例如，-Xmn256m 表示将年轻代的大小设置为 256 MB。 -XX:MaxPermSize=&lt;size&gt;：设置最大永久代（PermGen）大小。&lt;size&gt; 的格式和单位与 -Xmx 参数相同。例如，-XX:MaxPermSize=128m 表示将最大永久代大小设置为 128 MB。 -XX:ParallelGCThreads=&lt;num&gt;：设置并行垃圾回收的线程数。&lt;num&gt; 是一个整数值，表示线程的数量。例如，-XX:ParallelGCThreads=4 表示使用 4 个线程进行并行垃圾回收。 -XX:+UseConcMarkSweepGC：启用并发标记清除（CMS）垃圾回收器。例如，-XX:+UseConcMarkSweepGC 表示使用 CMS 垃圾回收器。 -XX:+PrintGCDetails：在控制台上打印详细的垃圾回收信息。例如，-XX:+PrintGCDetails 表示打印详细的垃圾回收信息。 这些只是一小部分常见的参数，还有许多其他参数可以用来调整 JVM 的行为。您可以参考 Oracle JDK 文档中的详细参数列表来了解更多选项和说明。 请注意，不同的 JDK 版本可能会有不同的参数和行为，因此建议在具体应用中根据需求和性能进行适当的调整和配置。","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2023-10-18T16:00:00.000Z","updated":"2023-11-06T06:44:15.778Z","comments":true,"path":"2023/10/19/Git常用命令/","link":"","permalink":"http://example.com/2023/10/19/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查看当前项目的所有远程分支1234567git branch -r# 如果只想查看远程分支的名称，可以使用 --list 或 -l 选项git branch -r --list# 查看当前分支的远程地址git remote show origin# 删除远程分支git push origin --delete feature/branch-1 查看当前项目的所有本地分支1234567git branch # 如果只想查看远程分支的名称，可以使用 --list 或 -l 选项git branch --list# 如果想查看本地分支的详细信息，可以使用 -v 选项git branch -v# 删除本地分支git branch -d feature/branch-1 查看某个分支的最近一次提交12# 使用 -1 选项可以限制日志输出为只显示一次提交git log -1 prod-v3.9.1 查看某个作者的最近一次提交12# &lt;author-name&gt; 是你要查找的作者的名称git log --author=&quot;John Doe&quot; -n 1 查看当前分支某个文件的最近一次提交12# HEAD表示最新的提交git show head src/main/java/com/ylsk/b2b3/service/sys/UserAgentService.java 查看某一次提交的所有文件 12# &lt;commit-hash&gt; 是你要查看的提交的哈希值或引用git show --name-only 4505f7817a4f56b4e8581ea8985609b7ef47748b 查看某一次提交的某个文件的详细内容1git show 4505f7817a4f56b4e8581ea8985609b7ef47748b wyt/custMap/CustMapSurveyInfoToESRepo.yml 合并分支12# 注意如果有冲突发生，你需要解决冲突并手动提交修改。冲突文件会在合并日志中显示git merge &lt;other_branch&gt; 暂存当前分支改动123456# 1.暂存当前分支的改动代码git stash# 2.切换到目标分支git checkout feature/branch-1# 3.弹出之前分支暂存的改动代码git stash pop","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-03-18T16:00:00.000Z","updated":"2024-05-29T02:29:08.225Z","comments":true,"path":"2023/03/19/hello-world/","link":"","permalink":"http://example.com/2023/03/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"markdown常用语法","slug":"markdown常用语法","date":"2023-03-18T16:00:00.000Z","updated":"2024-05-29T02:28:42.410Z","comments":true,"path":"2023/03/19/markdown常用语法/","link":"","permalink":"http://example.com/2023/03/19/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","excerpt":"","text":"官方教程：https://markdown.com.cn/basic-syntax/blockquotes.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 这是一级标题## 这是二级标题###### 这是六级标题&gt; 这是一个有两段的块引用。这是第一段&gt; &gt; 这是第二段。Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; 这是另一个只有一个段落的块引用。有三个空行分割两个块引用。### 无序列表* 红色* 绿色* 蓝色### 有序列表1. 红色2. 绿色3. 蓝色### 任务列表- [ ] 这是一个任务列表项- [ ] 需要在前面使用列表的语法- [ ] 未完成- [x] 完成### 代码块例如：~~~ruby 代码 ~~~### 表格| 第一列 | 第二列 | 第三列 || ------ | ------ | ------ || 第一行 | 1 | 张三 || 第二行 | 2 | 李四 || 第三行 | 3 | 王五 |### 水平线***### 链接this is [ an example](http://example.com/ &quot;Title&quot;) inline link.[ this link ](http://example.net/) has no title attribute.### URL网址&lt;www.google.com&gt;### 高亮必须先到设置中启用它。==高亮==### HTML您可以使用HTML来设置纯 Markdown 不支持的内容，例如， &lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt; 用于添加红色文本。### 表情符号输入表情符号的语法是 :smile:","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]}],"categories":[],"tags":[{"name":"管理","slug":"管理","permalink":"http://example.com/tags/%E7%AE%A1%E7%90%86/"},{"name":"项目管理","slug":"项目管理","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"技术设计","slug":"技术设计","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"历史","slug":"历史","permalink":"http://example.com/tags/%E5%8E%86%E5%8F%B2/"}]}